# analysis code for "Variation in Ubiquitin System Genes Creates
# Substrate-Specific Effects on Proteasomal Protein Degradation"

* Density Plot, Strip Chart, and TFT Ratio Heatmap                        :R:
#+BEGIN_SRC R :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/N-end_TFT_heatmap.R
## -----
## load all the required packages
source("~/emacs/R/functions/load_flow_packages.R")

#############
## USER INPUT
#############
reporter_names <- c("Gln_TFT", "Asn_TFT", "Glu_TFT", "Asp_TFT",
                    "Ile_TFT", "His_TFT", "Tyr_TFT", "Trp_TFT",
                    "Leu_TFT", "Phe_TFT", "Lys_TFT", "Arg_TFT",
                    "Thr_TFT", "Met_TFT", "Pro_TFT", "Val_TFT",
                    "Gly_TFT", "Ser_TFT", "Ala_TFT", "Cys_TFT")
base_dir       <- "~/data/flow/N-end_all_reporters/"
work_dir       <- paste0(base_dir, "fcs/")
frame_dir      <- paste0(base_dir, "dataframes/")
gated_dir      <- paste0(frame_dir, "gated/")
ungated_dir    <- paste0(frame_dir, "ungated/")
#################
## END USER INPUT
#################


## -----
## we'll loop over all the reporter names to
## [1] read in all the fcs files for a given reporter
## [2] gate each file based on fsc
## [3] write each collection of files to a data table
## [4] add variables for downstream processing (strain/reporter names, e.g.)
for (k in 1:length(reporter_names)) {

## -----
## [x]
## name the strains based on reporter, then set
## regex for getting flowsets of the different strains
## generally, should name fcs files as follows:
## strain    - by, rm, rpn4, ...
## reporter  - Ala TFT, Arg TFT, ....
## replicate - 001, 002, etc... per strain
## e.g., "RM_Arg_TFT_001.fcs"

## this is my current approach to reading in files.  the idea is to
## put all the various strains I've used in the past here and filter this
## complete set to those strains present in the actual data I'm analyzing.  I
## pre-filter using 'grepl' because 'read.flowset' throws an error if any term
## you supply it doesn't match.
no_reporter  <- paste0(".*untagged.*", reporter_names[k], ".*fcs") 
by_strain    <- paste0("BY.*", reporter_names[k], ".*fcs") 
rm_strain    <- paste0("RM.*", reporter_names[k], ".*fcs") 
rpn4_strain  <- paste0("rpn4.*", reporter_names[k], ".*fcs") 
ubr1_strain  <- paste0("ubr1.*", reporter_names[k], ".*fcs") 
doa10_strain <- paste0("doa10.*", reporter_names[k], ".*fcs") 
pop_1_strain <- paste0("SFA.*pop_001.*", reporter_names[k], ".*fcs") 
pop_5_strain <- paste0("SFA.*pop_005.*", reporter_names[k], ".*fcs") 
pop_6_strain <- paste0("SFA.*pop_006.*", reporter_names[k], ".*fcs") 

all_strains <- c(no_reporter, by_strain, rm_strain,
                 rpn4_strain, ubr1_strain, doa10_strain,
                 pop_1_strain, pop_5_strain, pop_6_strain)

## 'dir' lists the contents of a directory - test whether each strain regex
## matches any files in the list produced by 'dir'.  if a match occurs, the
## value returned by 'max' will be 1, else 0.  take only the strains that
## returned a match in the 2nd step below w/ 'all.strains <- ...'
true_strains <- sapply(all_strains, function(strain){
                           as.logical(max(grepl(pattern = strain,
                                                x = dir(path = work_dir,
                                                        pattern = ".*.fcs",
                                                        include.dirs = F,
                                                        ignore.case = T,
                                                        recursive = F,
                                                        no.. = T))))
                       })

all_strains <- as.list(all_strains[true_strains])

all_set     <- lapply(all_strains, function(strain){
                          read.flowSet(files = NULL,
                                       path = work_dir,
                                       pattern = strain,
                                       alter.names = T,
                                       min.limit = 1)
                      })
## str(all_set[[1]]@phenoData@data$name)

name_list <- strsplit(x = names(true_strains)[true_strains == T],
                      split = "\\.\\*")

names(all_set) <- unlist(lapply(X = name_list, FUN = function(x) {
                                    x[1] }))

## -----
## <<Color_Setup>>
## linking colors to strain names in R
## I think I should be able to make something
## akin to an lisp association list where
## there is a strain name and associated color
col_untagged <- c(color = gray(0.7),   name = "no reporter")
## 2021.01.27 - new colors for BY/RM
## col_by       <- c(color = "#7A9BCCFF", name = ".*BY.*")
col_by       <- c(color = "#2166ACFF", name = ".*BY.*")
## col_rm       <- c(color = "#CC7AAAFF", name = ".*RM.*")
col_rm       <- c(color = "#BF3232FF", name = ".*RM.*")
## col_rpn4     <- c(color = "#CCAB7AFF", name = ".*rpn4.*")
col_rpn4     <- c(color = "#CCA14AFF", name = ".*rpn4.*")
## col_ubr1     <- c(color = "#88CCBBFF", name = ".*ubr1.*")
col_ubr1     <- c(color = "#78BCABFF", name = ".*ubr1.*")
## col_doa10    <- c(color = "#A3CC7AFF", name = ".*doa10.*")
col_doa10    <- c(color = "#83BC6AFF", name = ".*doa10.*")
col_pop_1    <- c(color = gray(0.7),   name = ".*population.*1.*")
col_pop_5    <- c(color = "#AA1111FF", name = ".*population.*5.*")
col_pop_6    <- c(color = gray(0),     name = ".*population.*6.*")

cols_list    <- list(col_untagged, col_by, col_rm, 
                     col_rpn4, col_ubr1, col_doa10,
                     col_pop_1, col_pop_5, col_pop_6)

col_out <- sapply(X = cols_list, FUN = function(x){
                      grepl(pattern = x["name"],
                            x = name_list)
                  })

col_out <- as.logical(unlist(sapply(1:ncol(col_out),
                                    FUN = function(x){
                                        max(col_out[, x])
                                    })))

all_cols <- unlist(sapply(X = cols_list[col_out],
                          FUN = function(x){identity(x["color"])}))

names(all_cols) <- names(all_set)

## output a dummmy plot to assess strain/color mapping
## setwd(results.dir)
## pdf(file = "color_mapping.pdf", height = 7, width = 7, bg = "transparent")
barplot(rep(4, length(name_list)), col = all_cols, ylim = c(0, 7))
box()
legend(x = "topleft", legend = names(all_set),
       lty = 1, lwd = 7.5, col = all_cols,
       bg = "white")
legend(x = "topright", y = NA,
       legend = unlist(lapply(X = cols_list, FUN = function(x){identity(x)["name"]})),
       col = unlist(lapply(X = cols_list, FUN = function(x){identity(x)["color"]})),
       lty = 1, lwd = 7.5,  bg = "white")
## dev.off()


## a function to gate the cells to include only haploids.
## we identify these as a sharp peak in the lower end of
## the fsc density plot.  I take 10% above and below the
## max density value
fsc_gate_generator <- function(fl_frame){
    fsc_dens  <- density(exprs(fl_frame[, 1]))
    ## return the index of the maximum y value of the density estimate
    fsc_max   <- fsc_dens[[1]][which.max(fsc_dens[[2]])]
    fsc_upper <- (fsc_max * 0.10) + fsc_max
    fsc_lower <- fsc_max - (fsc_max * 0.10)
    fsc_gate  <- c(fsc_lower, fsc_upper)
}

fsc_split <- function(x){
    split(x, f = rectangleGate("FSC.A" = fsc_gate_generator(x)),
          population = "defaultRectangleGate+",
          flowSet = T, codeflowSet = T)}

## gate all samples on FSC
fsc_set <- lapply(all_set, fsApply, fsc_split)

## convert gated samples from flowsets to flowframes 
fsc_frame <- lapply(fsc_set, function(set) {
                        lapply(set, set2Frame)
                    })

## pull dataframes from flowframes for gated and
## ungated sets of samples, then rename 
fsc_gate_exprs <- vector(mode = "list", length = length(all_set))
no_gate_exprs  <- fsc_gate_exprs

for(j in 1:length(fsc_frame)) {
    for (i in 1:length(fsc_frame[[j]])) {
        fsc_gate_exprs[[j]][[i]] <- as.data.frame(exprs(fsc_frame[[j]][[i]]))
        fsc_gate_exprs[[j]][[i]]$strain <- as.factor(names(fsc_frame[j]))
        fsc_gate_exprs[[j]][[i]]$replicate <- as.factor(i)
    }
    fsc_gate_exprs[[j]] <- do.call("rbind", fsc_gate_exprs[[j]])
} 

## bind into a single dataframe
fsc_gate_exprs <- do.call("rbind", fsc_gate_exprs)

## add transformation parameters
fsc_gate_exprs$log_GFP   <- log10(fsc_gate_exprs$eGFP.A)
fsc_gate_exprs$log_RFP   <- log10(fsc_gate_exprs$mCherry.A)
fsc_gate_exprs$TFT_ratio <- log2(fsc_gate_exprs$mCherry.A / fsc_gate_exprs$eGFP.A)
fsc_gate_exprs$reporter  <- as.factor(rep(x = gsub(pattern = "_",
                                                  replacement = " ",
                                                  x = reporter_names[k]),
                                         times = nrow(fsc_gate_exprs)))

## nested loops for the ungated data
for (j in 1:length(all_set)){
    for (i in 1:length(all_set[[j]])) {
        no_gate_exprs[[j]][[i]] <- as.data.frame(exprs(all_set[[j]][[i]]))
        no_gate_exprs[[j]][[i]]$strain <- as.factor(names(all_set[j]))
        no_gate_exprs[[j]][[i]]$replicate <- as.factor(i)
    }
    no_gate_exprs[[j]] <- do.call("rbind", no_gate_exprs[[j]])
}

## bind into a single dataframe
no_gate_exprs <- do.call("rbind", no_gate_exprs)

## add transformation parameters and reporter var
no_gate_exprs$log_GFP   <- log10(no_gate_exprs$eGFP.A)
no_gate_exprs$log_RFP   <- log10(no_gate_exprs$mCherry.A)
no_gate_exprs$TFT_ratio <- log2(no_gate_exprs$mCherry.A / no_gate_exprs$eGFP.A)
no_gate_exprs$reporter  <- as.factor(rep(x = gsub(pattern = "_",
                                                  replacement = " ",
                                                  x = reporter_names[k]),
                                         times = nrow(no_gate_exprs)))

## write the ungated data to the appropriate dir
write.table(x = no_gate_exprs,
            file = paste0(ungated_dir,
                          reporter_names[k],
                          "_all_ungated.csv"),
            append = F, sep = ",",
            quote = F, row.names = F)

## write the gated data to the appropriate dir
write.table(x = fsc_gate_exprs,
            file = paste0(gated_dir,
                          reporter_names[k],
                          "_all_gated.csv"),
            append = F, sep = ",",
            quote = F, row.names = F)

    }

## now, read each reporter's dataframe in and
## combine into a single dataframe
## generate a list of files in a directory using
## the 'dir' command, e.g.:
## dir(gated_dir)
## dir(ungated_dir)

## '_u' = ungated
out_u <- vector(mode = "list", length = length(dir(ungated_dir)))
for (o in 1:length(dir(gated_dir))) {
    out_u[[o]] <- read.table(file = paste0(ungated_dir, dir(ungated_dir)[o]),
                             header = T, sep = ",")
       }

## '_g' = gated
out_g <- vector(mode = "list", length = length(dir(gated_dir)))
for (o in 1:length(dir(gated_dir))) {
    out_g[[o]] <- read.table(file = paste0(gated_dir, dir(gated_dir)[o]),
                             header = T, sep = ",")
       }

## for the ungated set, it'll be
## 1e5 cells * 5 strains/reporter * 20 reporters = 1e7 rows
## fsc gating reduces 1e5 to ~2e4, so ~2e6 rows
## nrow(out_all) = 2284942
out_all <- do.call("rbind", out_g)
str(out_all)
levels(out_all$reporter)

## split by type I/II Arg/N-end 
aa_order <- c(2, 3, 4, 6, 7, 9, 12, 10, 11, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)

## get the strain factor in the desired order 
out_all$strain <- factor(out_all$strain,
                         levels = levels(out_all$strain)[c(1, 3, 4, 5, 2)])

strain_paste <- expand.grid(unique(out_all$replicate),
                          levels(out_all$strain))

strain_paste <- paste0(strain_paste$Var2, "_", strain_paste$Var1)

out_all$strain_rep <- factor(paste0(out_all$strain, "_", out_all$replicate),
                             levels = strain_paste)

rep_cols <- unlist(lapply(X = 1:length(all_cols), FUN = function(x) {
                       rep(all_cols[x],
                           times = sum(grepl(pattern = names(all_cols[x]), 
                                             x = levels(out_all$strain_rep))))
                   }))

## need to order levels of 'strain_rep' like 'strain'
## 2021.01.20 - split by type I/II Arg/N-end 
aa_order <- c(2, 3, 4, 6, 7, 9, 12, 10, 11, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)
out_all$o_reporter <- factor(out_all$reporter,
                             levels = levels(out_all$reporter)[aa_order])
levels(out_all$o_reporter)
params <- colnames(out_all)[unlist(lapply(X = out_all, FUN = is.numeric))]
params[10] <- "log2 TFT Ratio"

## <<session_restore_point>>
## from this point, I've:
## 1. loaded all N-end TFT flowsets into R
## 2. assigned colors
## 3. gated the cells on the basis of FSC
## 4. build dataframes from the flowsets
## 5. *ordered the reporters by type and alphabetical*
## save.session(file = "~/Desktop/2021.01.29_all_flow_sets_loaded")
source("~/emacs/R/functions/load_flow_packages.R")
restore.session(file = "~/Desktop/2021.01.29_all_flow_sets_loaded")
## ls()

## <<density_plot_final>>
## have to set up parameters for a custom legend first...
## drop everything for building a custom legend
## into a list.  loop over the list by position
## ('top' or 'bottom') and strain to make 2
## legends in the panels 
top_legend_params <- list()
top_legend_params$names <- c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta)))
top_legend_params$line_x1     <- rep(0.8, 5)
top_legend_params$line_x2     <- rep(1.15, 5)    
top_legend_params$x_positions <- rep(x = 1.2, times = 5)
top_legend_params$y_positions <- rev(seq(from = 12.7, to = 13.45, length.out = 5))
top_legend_params$color       <- all_cols
bot_legend_params <- top_legend_params
top_legend_params$y_positions <- rev(seq(from = 4.75, to = 5.5, length.out = 5))
legend_params <- list(top_legend_params, bot_legend_params)

{
pdf(file = "~/Desktop/2022.01.29_density_full_final.pdf", height = 14.5, width = 14)
print(

densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = out_all,
            xlim = c(-7, 1.5),
            ## set alternating = F for one side, same side labeling
            Scales = list(alternating = 3),
            grid = T,
            plot.points = F,
            lwd = 2,
            main = list(label = "Arg/N-end Reporters"),
            sub = list(label = "Ac/N-end Reporters"),
            between = list(x = c(0, 0, 0),
                           y = c(0, 0, 3)),
            as.table = T,
            ylab = ",,",
            xlab = gsub(pattern = "_",
                        replacement = " ",
                        params[10]),
            index.cond = list(aa_order),
            par.settings = list(strip.background = list(col = gray(0.9)),
                                clip = list(panel = FALSE),
                                par.main.text = list(font = 2,
                                                     cex = 1.25,
                                                     just = "center", 
                                                     x = grid::unit(7, "in")),
                                par.sub.text = list(font = 2,
                                                    just = "center",
                                                    cex = 1.25,
                                                    x = grid::unit(7.05, "in"),
                                                    y = grid::unit(5.95, "in")),
                                axis.text = list(cex = 1),
                                par.ylab.text = list(cex = 1.25,
                                                     col = "white"),
                                par.xlab.text = list(cex = 1.25)),
            ## legend = list(inside = list(fun = grid.legend,
            ##                             args = list(labels = c("BY", "RM",
            ##                                   expression(paste("BY rpn4", Delta)), 
            ##                                   expression(paste("BY ubr1", Delta)), 
            ##                                   expression(paste("BY doa10", Delta))),
            ##                                   do.lines = T,
            ##                                   nrow = 5,
            ##                                   draw = T,
            ##                                   hgap = 1,
            ##                                   vgap = 0.25,
            ##                                   gp = gpar(col = all_cols,
            ##                                             lwd = 5,
            ##                                             cex = 1,
            ##                                             lineend = "butt",
            ##                                             npc = 50
            ##                                                   )))),
            ## key = list(text = list(c("BY", "RM",
            ##                           expression(paste("BY rpn4", Delta)),
            ##                           expression(paste("BY ubr1", Delta)),
            ##                           expression(paste("BY doa10", Delta)))),
            ##             lines = list(col = all_cols,
            ##                          lwd = 5),
            ##            corner = c(0, 1),
            ##            y = 0.98),
            panel = function(x, y, q, subscripts, ...) {
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_all$strain_rep,
                                  subscripts = subscripts,
                                  as.table = T,
                                  lty = 1,
                                  col = rep_cols,
                                  lwd = 0.75)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_all$strain,
                                  subscripts = subscripts,
                                  as.table = t,
                                  lty = 1,
                                  lwd = 1.5,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)


## <<plot_legend>>
## this gets placed outside the 'print' call
## write out a legend using 'grid.text' and 'grid.lines'
## because I separate the 2 N-end pathways, doubling
## the legend makes for a better visual layout.
## turns out there's not a straightforward way to
## double or position legends built using the lattice
## 'key' argument or grid.legend.  the code below works,
## but it's a bit hacky...
for (k in 1:length(legend_params)) {
    for (l in 1:length(legend_params[[1]])) {
        grid.text(label = legend_params[[k]]$names[l],
                  x = legend_params[[k]]$x_positions[l],
                  y = legend_params[[k]]$y_positions[l],
                  default.units = "in",
                  just = "left",
                  gp = gpar(col = "black", cex = 1))
        grid.lines(x = c(legend_params[[k]]$line_x1[l],
                         legend_params[[k]]$line_x2[l]),
                   y = c(legend_params[[k]]$y_positions[l],
                         legend_params[[k]]$y_positions[l]),
                   default.units = "in",
                   gp = gpar(lwd = 4, lineend = "butt",
                             col = legend_params[[k]]$color[l]))
    }
}

## replace improper y label positioning w/ custom text
## and double it since we've split the plot into 2 panels
grid.text(label = "Density",
          x = c(0.15, 0.15),
          y = c(7.5, 2),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )

dev.off()
}

## <<example_density_plot_trp_met_final>>
## grab a set of reporters that illustrate
## the deletion phenotypes.  for now, we'll
## use Met and Trp TFTs for this purpose.
out_tw <- out_all[out_all$reporter == "Met TFT" | out_all$reporter == "Trp TFT", ]

{
pdf(file = "~/Desktop/2022.01.29_example_density_2_panel_new_colors.pdf", height = 8, width = 5)
print(
densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = out_tw,
            xlim = c(-8, 1.5),
            ## set alternating = F for one side, same side labeling
            scales = list(alternating = 1,
                          tck = c(1, 0)),
            grid = T,
            plot.points = F,
            lwd = 2,
            as.table = F,
            ylab = ",",
            xlab = "log2 TFT ratio",
            par.settings = list(strip.background = list(col = gray(0.9)),
                                clip = list(panel = FALSE),
                                par.main.text = list(font = 2,
                                                     cex = 1.25,
                                                     just = "center", 
                                                     x = grid::unit(7, "in")),
                                par.sub.text = list(font = 2,
                                                    just = "center",
                                                    cex = 1.25,
                                                    x = grid::unit(7.05, "in"),
                                                    y = grid::unit(5.95, "in")),
                                axis.text = list(cex = 1),
                                par.ylab.text = list(cex = 1.25,
                                                     col = "white"),
                                par.xlab.text = list(cex = 1.25)),
            panel = function(x, y, q, subscripts, ...) {
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain_rep,
                                  subscripts = subscripts,
                                  as.table = T,
                                  lty = 1,
                                  col = rep_cols,
                                  lwd = 0.75)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain,
                                  subscripts = subscripts,
                                  as.table = t,
                                  lty = 1,
                                  lwd = 2,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)
## this gets placed outside the 'print' call
## write out a legend using 'grid.text' and 'grid.lines'
## because I separate the 2 N-end pathways, doubling
## the legend makes for a better visual layout.
## turns out there's not a straightforward way to
## double or position legends built using the lattice
## 'key' argument or grid.legend.  the code below works,
## but it's a bit hacky...
## legend parameters
## drop everything for building a custom legend
## into a list.  loop over the list by position
## ('top' or 'bottom') and strain to make 2
## legends in the panels 
ex_top_legend_params <- list()
ex_top_legend_params$names <- c("BY", "RM",
                                expression(paste("BY rpn4", Delta)), 
                                expression(paste("BY ubr1", Delta)), 
                                expression(paste("BY doa10", Delta)))
## starting point of the lines in 'x'
ex_top_legend_params$line_x1     <- rep(0.9, 5)
## endind position of the lines in 'x'
ex_top_legend_params$line_x2     <- rep(1.25, 5)    
## position of the text in x - rep this 5 times for 5 strains
ex_top_legend_params$x_positions <- rep(x = 1.35, times = 5)
## position of the text in x - rep this 5 times for 5 strains
ex_top_legend_params$y_positions <- rev(seq(from = 6.55, to = 7.25, length.out = 5))
ex_top_legend_params$color       <- all_cols
ex_bot_legend_params <- ex_top_legend_params
ex_top_legend_params$y_positions <- rev(seq(from = 3.1, to = 3.85, length.out = 5))
ex_legend_params <- list(ex_top_legend_params, ex_bot_legend_params)
for (k in 1:length(ex_legend_params)) {
    for (l in 1:length(ex_legend_params[[1]])) {
        grid.text(label = ex_legend_params[[k]]$names[l],
                  x = ex_legend_params[[k]]$x_positions[l],
                  y = ex_legend_params[[k]]$y_positions[l],
                  default.units = "in",
                  just = "left",
                  gp = gpar(col = "black", cex = 1))
        grid.lines(x = c(ex_legend_params[[k]]$line_x1[l],
                         ex_legend_params[[k]]$line_x2[l]),
                   y = c(ex_legend_params[[k]]$y_positions[l],
                         ex_legend_params[[k]]$y_positions[l]),
                   default.units = "in",
                   gp = gpar(lwd = 4, lineend = "butt",
                             col = ex_legend_params[[k]]$color[l]))
    }
}
## replace improper y label positioning w/ custom text
## and double it since we've split the plot into 2 panels
grid.text(label = "Density",
          x = c(0.2, 0.2),
          y = c(2.3, 5.7),
          rot = 90,
          gp = gpar(cex = 1.25),
          default.units = "in")
dev.off()
}


## <<strip_plots>>
## these plots are built by extracting the mean/median
## of each biological replicate of each strain.  Thus,
## we reduce 10,000 observations of a replicate to a
## single value.  w/ 8 biological replicates per strain,
## we can make a nice stripplot of strain * reporter
## for the different parameters.  We'll also use this
## to make a levelplot/heatmap

## 'aggregate' creates a new dataframe from x by applying FUN to
## all unique combinations of the factors supplied to the 'by'
## argument - in this case, grab the mean of numeric data and
## keep everything else a factor 
out_agg <- aggregate.data.frame(x = out_all,
                                by = list(out_all$strain,
                                          out_all$reporter,
                                          out_all$replicate),
                            FUN = function(x) {
                                ifelse(is.numeric(x), mean(x), as.factor(x))
                            })

## 'aggregate' seems to strip the levels from factors, so add
## these back using the values present in the original dataframe
out_agg$strain <- factor(out_agg$strain,
                     levels = unique(out_agg$strain),
                     labels = levels(out_all$strain))

out_agg$reporter <- factor(out_agg$reporter,
                     levels = unique(out_agg$reporter),
                     labels = levels(out_all$reporter))

out_agg$strain_rep <- factor(out_agg$strain_rep,
                             levels = unique(out_agg$strain_rep),
                             labels = levels(out_all$strain_rep))

## need a color vector that maps to strains that's the
## length of levels(strain) * levels(replicate) (usually 40)
out_agg_cols <- vector()
for (i in 1:nrow(out_agg)) {
    out_agg_cols[i] <- all_cols[out_agg$strain[i] == names(all_cols)]
}

## convert to Z scores 
i <- 1

out_z <- list()
reporter <- levels(out_agg$reporter)
for (i in 1:length(reporter)) {
    
    z_mean <- mean(out_agg$TFT_ratio[out_agg$reporter == reporter[i]])
    z_sd   <- sd(out_agg$TFT_ratio[out_agg$reporter == reporter[i]])
    z_out  <- function(x) { ((x - z_mean) / (z_sd))  }
    out_subset <- out_agg[out_agg$reporter == reporter[i], ]
    
    for (j in 1:nrow(out_subset)) {
        out_subset$zTFT[j] <- z_out(out_subset$TFT_ratio[j])
        out_z[[i]] <- out_subset
}}

out_z <- do.call("rbind", out_z)
range(out_z$zTFT)

new_aa_order <- c(2, 3, 4, 6, 7, 9, 10, 11, 12, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)
out_z$r_order <- factor(out_z$reporter,
                        levels = levels(out_z$reporter)[rev(new_aa_order)])

out_z$t_order <- factor(out_z$reporter,
                        levels = levels(out_z$reporter)[rev(aa_order)])

## aggregate into a smaller data frame for the actual heatmap
out_m <- aggregate.data.frame(x = out_z,
                               by = list(out_z$strain,
                                         out_z$reporter),
                               FUN = function(x) {
                                   ifelse(is.numeric(x), mean(x), as.factor(x))
                               })

out_m$strain <- factor(out_m$strain,
                        levels = unique(out_m$strain),
                        labels = levels(out_all$strain))

out_m$reporter <- factor(out_m$reporter,
                          levels = unique(out_m$reporter),
                          labels = levels(out_all$reporter))

out_m$r_order <- factor(out_m$reporter,
                        levels = levels(out_m$reporter)[rev(new_aa_order)])

out_m$t_order <- factor(out_m$reporter,
                        levels = levels(out_m$reporter)[rev(aa_order)])


hm_cols <- rev(brewer.pal(n = 11, name = "PiYG"))

{
pdf(file = "~/Desktop/2022.01.20_TFT_heat_final.pdf", height = 14, width = 6)
print(
levelplot(zTFT ~ strain * t_order,
          strip = T,
          xlab = "normalized TFT score",
          ylab = "Reporter",
          data = out_m,
          pretty = T,
          col.regions = hm_cols,
          ylab.right = "Z score",
          scales = list(alternating = F,
                        x = list(labels = c("BY", "RM",
                                            expression(paste("BY rpn4", Delta)), 
                                            expression(paste("BY ubr1", Delta)), 
                                            expression(paste("BY doa10", Delta))),
                                 rot = 45),
                        ## scales only on left/bottom
                        tck = c(1, 0)),
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              layout.heights = list(xlab.key.padding = 1),
                              layout.widths = list(left.padding = 5),
                              axis.text = list(cex = 1.25),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)), 
##          col.regions = gray(level = 29:0/29),
          at = seq(from = -2, to = 2, length.out = 10),
          colorkey = list(at = seq(from = -2, to = 2, length.out = 11),
                          cex = 1.25,
                          title = "normalized TFT score",
                          space = "bottom",
                          columns = 1,
                          row = 10),
          border = gray(0.3),
          as.table = T,
          ## index.cond = list(aa_order),
          border.lwd = 2)
)
## Ac/N-end reporter lines
grid.lines(x = c(0.65, 0.65),
           y = c(2.4, 6.42),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0.4)))
## Ac/N-end reporter text
grid.text(x = 0.3, y = 4.41,
          label = "Ac/N-end\nReporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
## type I Arg/N-end reporter lines
grid.lines(x = c(0.65, 0.65),
           y = c(9.83, 13.25),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0.4)))
## type I Arg/N-end reporter text
grid.text(x = 0.3, y = 11.5,
          label = "Type I Arg/N-end\nReporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
## type II Arg/N-end reporter lines
grid.lines(x = c(0.65, 0.65),
           y = c(6.95, 9.25),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0.4)))
## type II Arg/N-end reporter text
grid.text(x = 0.3, y = 8.1,
          label = "Type II Arg/N-end\nReporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
dev.off()
}


## <<Z_score_stripplot_final>>
{
pdf(file = "~/Desktop/2022.01.20_z_strip_full_final.pdf", height = 14.5, width = 14)
print(
stripplot(zTFT ~ strain | reporter,
          data = out_z,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)
## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))
## y axis labels for the strip
grid.text(label = "normalized TFT score",
          x = c(0.15, 0.15),
          y = c(10.17, 3.9),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )
dev.off()
}


## <<horizontal_N-end_heatmap>>
## 1. reverse levels on strain
out_m$strain_rev <- factor(out_m$strain,
                           levels = levels(out_m$strain)[5:1])
## 2. reverse levels on reporter
out_m$t_order_rev <- factor(out_m$t_order,
                           levels = levels(out_m$t_order)[20:1])

{
pdf(file = "~/Desktop/2022.01.20_N-end_horizontal_heatmap.pdf", height = 5, width = 14)
print(
levelplot(zTFT ~ t_order_rev * strain_rev,
          data = out_m,
          strip = T,
          ylab = "Strain",
          pretty = T,
          scales = list(alternating = F,
                        y = list(labels = c(expression(paste("BY doa10", Delta)),
                                            expression(paste("BY ubr1", Delta)),
                                            expression(paste("BY rpn4", Delta)),
                                            "RM", "BY")),
                        x = list(labels = gsub(pattern = " TFT", replacement = "",
                                               x = levels(out_m$t_order_rev)),
                                 rot = 45),
                        ## scales only on left/bottom
                        tck = c(1, 0)),
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.5,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              layout.heights = list(xlab.key.padding = 1,
                                                    bottom.padding = 3),
                              layout.widths = list(left.padding = 0,
                                                   right.padding = 10),
                              axis.text = list(cex = 1.5),
                              par.ylab.text = list(cex = 1.5,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.5,
                                                   col = "white")), 
          ## at = 1 less than number of ats in colorkey
          col.regions = brewer.pal(n = 11, name = "PiYG"),
          at = seq(from = 0, to = 3.6, length.out = 10),
          colorkey = list(at = 0:9,
                          labels = as.character(format(seq(from = 0, to = 3.6, length.out = 10),
                                                       nsmall = 1)),
                          cex = 1.5,
                          title = "Normalized UPS\nPathway Activity",
                          space = "right",
                          columns = 1,
                          row = 9),
          border = gray(0.3),
          as.table = T,
          border.lwd = 2)
)
## 3. add rotated text to colorkey
grid.text(label = "Normalized UPS\nPathway Activity",
          x = 13.6,
          y = 2.98,
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.5, font = 1))
## 4. add pathway lines 
## Type I Arg/N-end text
grid.text(label = "Type I Arg/N-end\nReporters",
          x = 3.6125,
          y = 0.35,
          default.units = "in",
          gp = gpar(cex = 1.5, font = 1))
## Type II Arg/N-end text
grid.text(label = "Type II Arg/N-end\nReporters",
          x = 6.725,
          y = 0.35,
          default.units = "in",
          gp = gpar(cex = 1.5, font = 1))
## Ac/N-end text
grid.text(label = "Ac/N-end\nReporters",
          x = 10.1,
          y = 0.35,
          default.units = "in",
          gp = gpar(cex = 1.5, font = 1))
## Type I Arg/N-end lines
grid.lines(x = c(2.05, 5.175),
          y = 0.75,
          default.units = "in",
          gp = gpar(col = gray(0), lwd = 2))
## Type II Arg/N-end lines
grid.lines(x = c(5.7, 7.75),
          y = 0.75,
          default.units = "in",
          gp = gpar(col = gray(0), lwd = 2))
## Ac/N-end lines
grid.lines(x = c(8.28, 11.92),
          y = 0.75,
          default.units = "in",
          gp = gpar(col = gray(0), lwd = 2))
dev.off()
}

## <<example_stripplots_final>>
## use met and trp for this purpose
## these will go into figure 1, but
## are just for illustration purposes...
out_x <- out_z[out_z$reporter == "Met TFT" | out_z$reporter == "Trp TFT", ]

{
pdf(file = "~/Desktop/2022.01.20_example_strip_2_panel_final.pdf", height = 8, width = 5)
print(
stripplot(zTFT ~ strain | reporter,
          data = out_x,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.25,
          scales = list(alternating = 1,
                        tck = c(1, 0),
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(1, 2),
          grid = T,
          as.table = F,
          jitter = T,
          factor = 1.7,
          ylab = "Z-score",
          xlab = "Strain",
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1.25),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          horizontal = F)
)
grid.text(label = "normalized TFT score",
          x = c(0.2, 0.2),
          y = c(2.75, 5.85),
          rot = 90,
          gp = gpar(cex = 1.25),
          default.units = "in")
dev.off()
}


## <<BY_RM_plot>>
## nrow(out_agg) = 800, so 300 should be BY or RM 
out_by_rm <- grepl(pattern = "[BR][YM]",
                   x = as.character(out_agg$strain))

out_br <- out_agg[out_by_rm, ]

out_br_cols <- vector()

for (i in 1:nrow(out_br)) {
out_br_cols[i] <- all_cols[out_br$strain[i] == names(all_cols)]
}

{
pdf(file = "~/Desktop/2022.01.20_by_rm_final.pdf", height = 14.5, width = 14)
print(
## need to make a TFT ratio amino acid index 
stripplot(TFT_ratio ~ strain | reporter,
          data = out_br,
          type = c("g", "p"),
          col = gray(0),
          fill = out_br_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM"))),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(5.95, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)
## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))

## y axis labels for the strip
grid.text(label = "log2 TFT ratio",
          x = c(0.15, 0.15),
          y = c(7.45, 1.85),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25))
dev.off() 
}
#+END_SRC

* All QTL Peaks Heatmap                                                   :R:
#+BEGIN_SRC R :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/QTL_heatmap.R
## -----
## code to make a heatmap of QTL peaks across multiple reporters 

## -----
## <<heatmap_setup>>
## ifelse to determine which system we're on
## if not on home machine, assume msi
system   <- Sys.info()["nodename"]
base_dir <- "~/data/illumina/"
## determine if we're on msi; set wd appropriately 
base_dir <- ifelse(system != "mahlon-linux",
                   "/home/albertf/mahlon/data/illumina/",
                   base_dir)

#############
## USER INPUT
#############
## set the specific directory you'll work 
## in and name the comparison table
## TRAILING SLASH AT END OF DIR
## below, your project, e.g.,
## "2021.08.17_FPFA002_TDH3pr_Arg_N-end_TFT_sorts/"
proj           <- "2021.10.30_all_UPS_rdata/peaks/merged_delta_AF_peak_tables/"
proj_dir       <- paste0(base_dir, proj)
peaks_table    <- read.table(file = paste0(proj_dir, "all_merged_peaks.csv"),
                             sep = ",", header = T)
#################
## END USER INPUT
#################


## -----
## <<avg_peak_table>>
## now make a table of the average LOD, delta_AF, and peak 
## positions that we'll use to construct the heatamp 
avg_table <- data.frame(reporter = peaks_table$reporter,
                        chr = peaks_table$chr,
                        LOD = (peaks_table$rep_1_LOD + peaks_table$rep_2_LOD) / 2,
                        delta_AF = (peaks_table$rep_1_delta_AF + peaks_table$rep_2_delta_AF) / 2,
                        left_Index = (peaks_table$rep_1_left_Index + peaks_table$rep_2_left_Index) / 2,
                        max_Index = (peaks_table$rep_1_max_Index + peaks_table$rep_2_max_Index) / 2 ,
                        right_Index = (peaks_table$rep_1_right_Index + peaks_table$rep_2_right_Index) / 2)

## write out the averaged table
write.table(x = avg_table,
            file = paste0(proj_dir, "averaged_merged_all_peaks_table.csv"),
            append = F, quote = F, sep = ",",
            row.names = F, col.names = T)

avg_table <- read.table(file = paste0(proj_dir, "averaged_merged_all_peaks_table.csv"),
                        header = T, sep = ",")

## -----
## <<common_functions_code_
## needed tables, files, etc....
## SNPs is a giant table w/ SNP positions 
SNPs           <- read.table("~/QTL_scripts/SNPs_Maggie_170809_BY_positions.txt",
                             stringsAsFactors=FALSE,
                             head=FALSE)

## as of 8/31/17, the SNPs seem not to be fully
## filtered and are out of sorting order
## I think the next section duplicates this code
## w/o the loop.  Frank's comment suggests he
## thinks the 'for' loop isn't working, but I
## think it is.  Does Maggie's code fix it?
## I guess not, given the dates.  
for (thisChr in unique(SNPs[,1])){
    SNPs[SNPs[,1] == thisChr, 2] <- sort(SNPs[SNPs[,1] == thisChr, 2])
}
SNPs <- rbind(SNPs[SNPs[, 1] == "chrI", ],
              SNPs[SNPs[, 1] == "chrII", ],
              SNPs[SNPs[, 1] == "chrIII", ],
              SNPs[SNPs[, 1] == "chrIV", ],
              SNPs[SNPs[, 1] == "chrV", ],
              SNPs[SNPs[, 1] == "chrVI", ],
              SNPs[SNPs[, 1] == "chrVII", ],
              SNPs[SNPs[, 1] == "chrVIII", ],
              SNPs[SNPs[, 1] == "chrIX", ],
              SNPs[SNPs[, 1] == "chrX", ],
              SNPs[SNPs[, 1] == "chrXI", ],
              SNPs[SNPs[, 1] == "chrXII", ],
              SNPs[SNPs[, 1] == "chrXIII", ],
              SNPs[SNPs[, 1] == "chrXIV", ],
              SNPs[SNPs[, 1] == "chrXV", ],
              SNPs[SNPs[, 1] == "chrXVI", ])

library("lattice")
library("latticeExtra")
library("RColorBrewer")
library("grid")

## check for Bioconductor and install if not available
ifelse(!requireNamespace("BiocManager", quietly = TRUE),
       install.packages("BiocManager",
                        dependencies = TRUE,
                        repos = "http://cran.wustl.edu/",
                        quiet = TRUE),
       paste0("Bioconductor available"))
require("BiocManager")

bioc_package_installer <- function(x){if(!requireNamespace(x))
                                          BiocManager::install(x,
                                                               INSTALL_opts = '--no-lock')}
bioc_package_installer("VariantAnnotation")

library("VariantAnnotation")
source("~/QTL_scripts/gTest.R")
source("~/QTL_scripts/x_qtl_seq_functions_170831.R")
source("~/QTL_scripts/mp_JB_170901.R")
source("~/QTL_scripts/peaksFromVector.R")
("~/QTL_scripts/chr_cutoffs.Rdata")
load("~/QTL_scripts/chr_labels.Rdata")

## data frame with all yeast genes, plus
## chr, pos., strand, and names 
geneInfo <- read.table("~/QTL_scripts/ensemblGenes_ensembl83_160307_MOD.txt",
                       stringsAsFactors=FALSE,
                       sep="\t",
                       header=TRUE)
## rownames become systemtatic names 
rownames(geneInfo) <- geneInfo[,"geneID"]
## "geneName" is the common name, e.g., 'HOG1'
## for some (many?) rows of 'geneInfo', there
## is no 'geneName', so it's just an empty string
## e.g., head(allNames)
allNames <- geneInfo[, "geneName"]

names(allNames) <- geneInfo[,1]
allNames[which(allNames == "")] <- names(allNames)[which(allNames == "")]
allNamesInv <- names(allNames)
names(allNamesInv) <- allNames

sepBetweenChr <- 0
trimFromEnd   <- 15e3
obsMin        <- 10
LoessSpan     <- 0.1
## same as in Albert 2014
AF_thres       <- 0.09653124
## multipool LOD threshold, our usual value 
multi_thres    <- 4.5


## -----
## <<heatmap_setup>>
## build a dummy dataframe to drop QTLs into
## ~120 bins if you use 100 kb windows for the map

## read in chr lengths
## need this for building the heatmap
chr_lengths <- read.table("~/QTL_scripts/sacCer3ChromLengths.txt", header = F)

## don't need mitochondrial chromosome 
chr_lengths <- chr_lengths[1:16, ]

## add the gcoords and numeric (not roman) chromosomes:
chr_lengths$chr <- 1:16
chr_lengths$gcoords <- getGcoords(chr = 1:16,
                                  pos = chr_lengths$chr,
                                  spacing = sepBetweenChr)
chr_lengths <- chr_lengths[, c(3, 1, 2, 4)]
names(chr_lengths) <- c("chr", "chr_r", "length", "gcoords")

## <<build_heatmap_dataframe>>
k <- 1
reporters <- levels(avg_table$reporter)

final <- list()
for (k in 1:length(reporters)) {    

## make a list of 16 containing the chr and bin as a dataframe
## have to round up the chr lengths so the bins are all the same
## size (1e5 bp)

## we need to make an extra bin for ea. chromosome, since the
## lengths don't end in 1e5 multiples.  'round_up' allows you
## to do this using a multiple of your choice.
## So, chrI = 230218 bp and round_up(230218, 1e5) = 3e5
round_up <- function(from, to) {
    ceiling(from / to) * to
    }

round_down <- function(from, to) {
    floor(from / to) * to
    }    

## assign each bin to the correct chromosome
chr_indices <- unlist(sapply(X = 1:16, FUN = function(x) {
                                 rep(x,
                                     times = length(seq(from = 1e5,
                                                        to = round_up(chr_lengths$length[x],
                                                                      to = 1e5),
                                                        by = 1e5)))
                      }))

## create chromosome bins - this will serve as a conditioning factor
bins <- seq(from = 1e5,
            to = length(chr_indices) * 1e5,
            by = 1e5)

## when we assign peaks to bins, we need to add the length of
## all preceding chromosomes plus the peak position.  we'll use
## the bin lengths, not the chromosome lengths for this purpose.
## so, a QTL on chrII at base 150 = 3e5 (length of chr I bins) + 150
bin_sums <- c(0, unlist(sapply(X = 2:16, FUN = function(x) {
                              max(bins[chr_indices == x - 1])
                              })))

## assign the peaks for ea. reporter to a dataframe 
out <- avg_table[avg_table$reporter == reporters[k], ]

## assign each peak a bin for the heatmap 
for (b in 1:nrow(out)) {
    out$bin[b] <- round_down(from = out$max_Index[b] + bin_sums[out$chr[b]],
                             to = 1e5)
}

## dummy dataframe that contains all bins    
chr_bins <- data.frame(reporter = rep(reporters[k], length(bins)),
                       chr = chr_indices,
                       LOD = rep(0, length(bins)),
                       delta_AF = rep(0, length(bins)),
                       left_Index = rep(0, length(bins)),
                       max_Index = rep(0, length(bins)),
                       right_Index = rep(0, length(bins)),
                       bin = bins)

## the bins above aren't exact, so assign them to one
## of the bins we defined using 'which.min'
## assign peaks to bins via 'which.min'
for (r in 1:nrow(out)) {
    ind <- out$chr[r]
    chrs <- chr_bins$bin[chr_bins$chr == ind & chr_bins$bin > out$bin[r]]
    out$bin[r] <- chrs[which.min(abs(out$bin[r] - chrs))]
}

## if there's a peak, replace the current row with the peak row
## if not, just leave everything at 0
for (n in 1:nrow(chr_bins)) {
    test <- min(abs(chr_bins[n, "bin"] - out$bin))
    ind  <- which.min(abs(chr_bins[n, "bin"] - out$bin))
    chr_bins[n, ] <- if(test == 0) out[ind, ] else chr_bins[n, ]
}

## assign the dataframe w/ each peak and peak bin position to a list
## that we'll collapse after we've run through all the reporters 
final[[k]] <- chr_bins
}

## collapse output to a single frame
test <- do.call("rbind", final)

## remove the "_" from the factor level
levels(test$reporter) <- gsub(pattern = "_", replacement = " ",
                              x = levels(test$reporter))

## square root transform LOD scores for better visualization
test$LOD_mult <- test$delta_AF / abs(test$delta_AF)

## make the LOD negative if the high - low BY allele frequency < 1
## 2021.01.20 - this doesn't really work and won't be in the final
## heatmap 
for (i in 1:length(test$LOD_mult)) {
    test$LOD_mult[i] <- if(is.nan(test$LOD_mult[i]) == T) 0 else test$LOD_mult[i]
    }

test$sq_LOD <- sqrt(test$LOD) * test$LOD_mult

## <<alphabetical_order>>
## put the amino acids in alphabetical order,
## but also split by pathway (Arg/N-end vs. Ac/N-end)
## have to reverse it due to the way lattice plots
## Arg/N-end: arg, asn, asp, gln, glu, his, ile, leu, lys, phe, trp, tyr
## Ac/N-end: ala, cys, gly, met, pro, ser, thr, val
aa_order  <- c(2, 3, 4, 6, 7, 9, 10, 11, 12, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)
## aa_order[order(aa_order)] == 1:20
test$aa_factor <- factor(test$reporter,
                    levels = levels(test$reporter)[rev(aa_order)])
## levels(test$aa_factor)

## <<type_I_II_order>>
## still alphabetical, but w/ Arg/N-end
## split by type I vs II ubr1 rec site
## type I  = arg asn asp gln glu his lys 
## type II = ile leu phe trp tyr 
## Ac/N-end: ala, cys, gly, met, pro, ser, thr, val
type_order <- c(2, 3, 4, 6, 7, 9, 12, 10, 11, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)
## type_order[order(type_order)] == 1:20
## levels(test$reporter)[type_order]
test$type_factor <- factor(test$reporter,
                           levels = levels(test$reporter)[rev(type_order)])
## levels(test$type_factor)

## <<dynamic_range_order>>
## timer dynamic range order (high to low):
## Arg/N-end: asn, trp, asp, phe, tyr, lys, arg, his, gln, ile, leu, glu
## Ac/N-end: cys, met, pro, val, ser, thr, ala, gly
deg_order <- c(3, 18, 4, 14, 19, 12, 2, 9, 6, 10, 11, 7, 5, 13, 15, 20, 16, 17, 1, 8)
test$deg_factor <- factor(test$reporter,
                          levels = levels(test$reporter)[rev(deg_order)])
## deg_order[order(deg_order)] == 1:20
## levels(test$reporter)[deg_order]

## position where the labels for the x axis (chr) go
chr_labels <- sapply(X = 1:16, FUN = function(x) {
                         mean(test$bin[test$chr == x])
                     })

## position where the dividing lines on the x axis go
chr_cutoffs <- sapply(X = 1:15, FUN = function(x) {
                          max(test$bin[test$chr == x]) + 5e4
})


sq_LOD_ats  <- c(seq(from = -16, to = -2, length.out = 4),
                 seq(from = 2, to = 16, length.out = 4))
sq_LOD_cols <- c(brewer.pal(10, "RdBu")[1:4],
                 "white", 
                 brewer.pal(10, "RdBu")[7:10])


## this object demarcates the bins on the colorkey
## 0.075 is the smallest delta_AF value for the QTLs
delta_AF_ats  <- c(seq(from = -0.7, to = -0.075, length.out = 4),
                   seq(from = 0.075, to = 0.7, length.out = 4))
## "RdBu" is colorlbind friendly:
## display.brewer.all(colorblindFriendly = TRUE)
## "PiYG" should work for the TFT plots
## look at a palette
## display.brewer.pal(10, "RdBu")
delta_AF_cols <- c(brewer.pal(10, "RdBu")[1:4],
                   "white", 
                   brewer.pal(10, "RdBu")[7:10])
{
pdf(file = "~/Desktop/2022.01.20_delta_AF_heatmap_final.pdf",
    height = 5.5, width = 11)
print( 
levelplot(delta_AF ~ bin * type_factor,
          data = test,
          xlab = "Chromosome",
          col.regions = delta_AF_cols,
          at = delta_AF_ats,
          colorkey = list(col = delta_AF_cols,
                          at = 0:7,
                          labels = as.character(c(-0.70, -0.50, -0.25, -0.075,
                                                  0.075, 0.25, 0.50, 0.70)),
                          ## reduce the height of the colorkey a bit:
                          height = 0.5,
                          title = "delta AF"),
          scales = list(x = list(at = chr_labels,
                                 tck = c(1, 0),
                                 alternating = 1,
                                 labels = as.roman(1:16)),
                        y = list(alternating = 1,
                                 tck = c(1, 0))),
          par.settings = list(layout.widths = list(left.padding = 3,
                                                   right.padding = 3.5),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white")),
          panel = function(...){
              panel.levelplot(...)
              panel.abline(v = chr_cutoffs,
                           lty = 1, col = gray(0.4))
              panel.abline(h = c(8.5, 13.5),
                           lty = 1, col = gray(0.4))
          })
)
## reporter text 
grid.text(x = rep(0.25, 3),
          y = c(4.35, 2.97, 1.6),
          label = c("Type I Arg/N-end\nReporters",
                    "Type II Arg/N-end\nReporters",
                    "Ac/N-end\nReporters"),
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 0.85),
          vp = "plot_01.toplevel.vp")
## heatmap key text
grid.text(x = 10.85,
          y = 2.92,
          label = expression(paste(Delta, "Allele Frequency (High vs. Low Pool)")),
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 0.85),
          vp = "plot_01.toplevel.vp")
## type I Arg/N-end reporter vertical line
grid.lines(x = c(0.5, 0.5),
           y = c(3.65, 4.95),
           default.units = "in",
           gp = gpar(col = gray(0.4), lwd = 1.5))
## type II Arg/N-end reporter vertical line
grid.lines(x = c(0.5, 0.5),
           y = c(2.55, 3.45),
           default.units = "in",
           gp = gpar(col = gray(0.4), lwd = 1.5))
## Ac/N-end reporter vertical line
grid.lines(x = c(0.5, 0.5),
           y = c(0.81, 2.35),
           default.units = "in",
           gp = gpar(col = gray(0.4), lwd = 1.5))
dev.off()
}

## find the viewport for the plot you're working on
grid.ls(viewport = T, grobs = F)


## this object demarcates the bins on the colorkey
## 0.075 is the smallest delta_AF value for the QTLs
delta_AF_ats  <- c(seq(from = -0.7, to = -0.075, length.out = 4),
                   seq(from = 0.075, to = 0.7, length.out = 4))
## "RdBu" is colorlbind friendly:
## display.brewer.all(colorblindFriendly = TRUE)
## "PiYG" should work for the TFT plots
## look at a palette
## display.brewer.pal(10, "RdBu")
delta_AF_cols <- c(brewer.pal(10, "RdBu")[1:4],
                   "white", 
                   brewer.pal(10, "RdBu")[7:10])
{
pdf(file = "~/Desktop/2022.01.20_delta_AF_heatmap_final.pdf",
    height = 5.5, width = 11)
print( 
levelplot(delta_AF ~ bin * type_factor,
          data = test,
          xlab = "chromosome",
          col.regions = delta_AF_cols,
          at = delta_AF_ats,
          colorkey = list(col = delta_AF_cols,
                          at = 0:7,
                          labels = as.character(c(-0.70, -0.50, -0.25, -0.075,
                                                  0.075, 0.25, 0.50, 0.70)),
                          ## reduce the height of the colorkey a bit:
                          height = 0.5,
                          title = "delta AF"),
          scales = list(x = list(at = chr_labels,
                                 tck = c(1, 0),
                                 alternating = 1,
                                 labels = as.roman(1:16)),
                        y = list(alternating = 1,
                                 tck = c(1, 0))),
          par.settings = list(layout.widths = list(left.padding = 3,
                                                   right.padding = 3.5),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white")),
          panel = function(...){
              panel.levelplot(...)
              panel.abline(v = chr_cutoffs,
                           lty = 1, col = gray(0.4))
              panel.abline(h = c(8.5, 13.5),
                           lty = 1, col = gray(0.4))
          })
)
## reporter text 
grid.text(x = rep(0.25, 3),
          y = c(4.35, 2.97, 1.6),
          label = c("Type I Arg/N-end\nReporters",
                    "Type II Arg/N-end\nReporters",
                    "Ac/N-end\nReporters"),
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 0.85),
          vp = "plot_01.toplevel.vp")
## heatmap key text
grid.text(x = 10.85,
          y = 2.92,
          label = expression(paste(Delta, "Allele Frequency (High vs. Low Pool)")),
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 0.85),
          vp = "plot_01.toplevel.vp")
## type I Arg/N-end reporter vertical line
grid.lines(x = c(0.5, 0.5),
           y = c(3.65, 4.95),
           default.units = "in",
           gp = gpar(col = gray(0.4), lwd = 1.5))
## type II Arg/N-end reporter vertical line
grid.lines(x = c(0.5, 0.5),
           y = c(2.55, 3.45),
           default.units = "in",
           gp = gpar(col = gray(0.4), lwd = 1.5))
## Ac/N-end reporter vertical line
grid.lines(x = c(0.5, 0.5),
           y = c(0.81, 2.35),
           default.units = "in",
           gp = gpar(col = gray(0.4), lwd = 1.5))
dev.off()
}

#+END_SRC

* TFT Cartoon Barchart                                                    :R:

#+BEGIN_SRC R :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/TFT_cartoon_barchart.R
library("lattice")
vals <- c(0.2, 0.6, (0.2 / 0.6), 0.8, 0.8, 1)
fac  <- as.factor(1:length(vals))

low_col <- "#ec6ab7ff"
high_col <-  "#5AC168ff"
TFT_col <- gray(0.9)

low_col  <- "#ec6ab7"
high_col <- "#88d392"

{
pdf("~/emacs/N-end_Rule_QTL_paper/figures_drafts/TFT_cartoon_barchart.pdf")

print(
barchart(vals ~ fac,
         type = c("g"),
         xlab = "Degradation Rate",
         ylab = "Intensity (a.u.)",
         ylim = c(-0.02, 1.05),
         xlim = c(0.7, 5.7),
         ## border col and lwd for the border around the bars
         border = gray(0.5),
         lwd = 2.5,
         ## Ratio of bar width to inter-bar space
         ## default seems to be > 1
         box.ratio = 1.2,
         col = c(low_col, high_col, TFT_col),
         scales = list(x = list(cex = 2.5,
                                at = c(2, 4.4),
                                labels = c("High", "Low")),
                       y = list(at = seq(from = 0, to = 1, by = 0.2),
                                cex = 2.5),
                       tck = c(1, 0)),
         par.settings = list(par.ylab.text = list(cex = 2.5),
                             par.xlab.text = list(cex = 2.5)),
         key = list(rectangles = list(col = c(low_col,
                                        high_col,
                                        TFT_col),
                                border = gray(0.4),
                                lwd = 10,
                                size = 6,
                                height = 0.7),
                    text = list(labels = c("RFP", "GFP", "RFP / GFP"),
                                cex = 2),
                    corner = c(0.01, 0.99),
                    padding.text = 5,
                    cex.border = 10,
                    between = 1,
                    background = "white",
                    border = gray(0.4)),
          panel = function(x, y, ...) {
             panel.abline(h = seq(from = 0, to = 1, by = 0.2),
                          v = c(0.8, 2, 3.2, 4.4, 5.6),
                          col = gray(0.9))
             ## taken from the 'panel.barchart' help
             ## specify the exact location of the bars
             ## x: Extent of Bars. By default, bars start at left of panel,
             ## unless ‘origin’ is specified, in which case they start there.
             ## y: Horizontal location of bars. Possibly a factor.
             ## but, flip them, since 'horizontal = F'
             panel.barchart(x = c(1.4, 2, 2.6, 3.8, 4.4, 5),
                            y = vals,
                            ...)
         })
)

dev.off()
}
#+END_SRC

* Replicating Peak Table Code                                         :ELISP:

#+BEGIN_SRC emacs-lisp :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/replicating_peaks_from_table.el
;; in-buffer creation of non-replicating peak tables

;; setup:
;; make variables for each table row
;; and a variable to dump table output into
(defun replicating-peak-table-generator ()
  "Generate replicating QTL peak tables in an org file."
  (interactive)
(let ((row-string)
      (table-list)
      (replicate-strings '("Replicate 1" "Replicate 2")))

  (dolist (r replicate-strings)
    (goto-char (point-min))
    (re-search-forward (concat r " Raw Table") nil t)
    (next-line)
    (while (org-at-table-p)
      (forward-char 1))
    ;; set up a heading to dump non-replicating peaks into
    (insert (concat "\n* " r " non-Replicating Peaks"))
    (goto-char (point-min))
    (re-search-forward (concat r " Final Table"))
    (replace-match (concat r " Replicating Peaks"))

  ;; go back to the table
    (goto-char (point-min))
    (re-search-forward (concat r " Raw Table") nil t)
    (while (not (org-at-table-p))
      (forward-char))
    (org-table-analyze)
    (org-table-goto-field "@2$2")

  ;; while in the table, check whether the peak replicated
  (while (org-at-table-p)
    (goto-char (line-beginning-position))
    (setq row-string (buffer-substring (point) (line-end-position)))
    (next-line 1)
    ;; if test
    ;; if the peak replicated, add the output to our table list
    ;; if not, do nothing
    (if (not
         (save-excursion
           (re-search-forward row-string (point-max) t)))
        (setq table-list (cons row-string table-list))
      (message "no"))
    )

  ;; reverse the list to get the peak order right
  (setq table-list (reverse table-list))

  ;;table creation
  ;; insert table header
  (re-search-forward
   (concat "\* " r " Replicating Peaks") (point-max))
  (insert "\n|----------+-----------+-----+--------+----------+------------+-----------+-------------|\n| reporter | replicate | chr |    LOD | delta_AF | left_Index | max_Index | right_Index |\n|----------+-----------+-----+--------+----------+------------+-----------+-------------|\n")
  (mapcar (lambda (arg) (insert (concat arg "\n"))) table-list)
  (setq table-list nil)
)
  )
)

;; export of peaks as .csv files
(defun all-peaks-export-from-org ()
  "Export replicating and non-replicating QTLs from an org file as a table."
  (interactive)
(let* ((reporter (substring (buffer-name (current-buffer)) 0 3))
       (replicate-strings '("Replicate 1" "Replicate 2"))
       (presence-strings '(" Replicating Peaks" " non-Replicating Peaks"))
       (full-strings))

  ;; set up string list
  (dolist (r replicate-strings)
    (dolist (p presence-strings)
      (setq full-strings (cons (concat r p) full-strings))))
  (setq full-strings (reverse full-strings))

  (dolist (f full-strings)
    (goto-char (point-min))
    (re-search-forward f nil)
    (while (not (org-at-table-p))
      (forward-char))
    (org-table-export
     (concat "~/data/illumina/2021.10.30_all_UPS_rdata/peaks/replicating_peak_tables/"
             reporter "_"
             (replace-regexp-in-string " " "_" f) ".csv"))
    ))
)
#+END_SRC

* Sequencing Median Coverage                                              :R:

#+BEGIN_SRC R

cover <- c(34, 30, 33, 33, 28, 22, 29, 31, 31, 27, 31, 35,
           19, 17, 12, 23, 25, 28, 33, 28, 33, 24, 28, 36,
           28, 24, 24, 25, 20, 23, 14, 17, 31, 29, 25, 26,
           18, 20, 28, 23, 29, 25, 14, 30, 35, 35, 29, 29,
           33, 22, 31, 41, 26, 31, 23, 29, 32, 28, 23, 16,
           30, 47)

median(cover)

#+END_SRC

#+RESULTS:
: 28

* Create Replicating/Non-Replicating Peak Tables                       :BASH:

#+BEGIN_SRC bash ~/emacs/N-end_Rule_QTL_paper/scripts/tables.sh
## -----
## check output of files to make sure it matches the
## corresponding table in the original .org file
## setup
## nrp = "non-replicating peaks"
nrp_dir=~/data/illumina/2021.10.30_all_UPS_rdata/peaks/non-replicating_peak_tables/
cd ${nrp_dir}

## e.g.,
files=$( find ${nrp_dir} -iregex ".*Ala.*Replicating.*.csv" )
echo ${files}

for f in ${files};
do
echo ${f}
column -t -s "," ${f}
done


## -----
## create tables for non-replicating and replicating peaks
## non-replicating peaks
## set up output file to drop non-replicating peaks into
non_rep_out=${nrp_dir}all_non-replicating_peaks.csv
touch ${non_rep_out}
echo "reporter,replicate,chr,LOD,delta_AF,left_Index,max_Index,right_Index" > ${non_rep_out}
cat ${non_rep_out}

non_rep_peaks=( $( find ${nrp_dir} -regex ".*non-Replicating_Peaks.csv" | sort ) )
declare -p non_rep_peaks

for r in ${non_rep_peaks[@]}
do
## 'tail -n +2' prints all but the first line of a file
cat ${r} | tail -n +2 >> ${non_rep_out}
done

## 156
cat ${non_rep_out} | tail -n +2 | wc -l
## inspect output
column -t -s "," ${non_rep_out}


## -----
## replicating peaks table
rep_peaks=( $( find ${nrp_dir} -regex ".*_Replicating_Peaks.csv" | sort ) )
declare -p rep_peaks

## set up output file to drop replicating peaks into
rep_out=${nrp_dir}all_replicating_peaks.csv
touch ${rep_out}
echo "reporter,replicate,chr,LOD,delta_AF,left_Index,max_Index,right_Index" > ${rep_out}
cat ${rep_out}

for r in ${rep_peaks[@]}
do
## 'tail -n +2' prints all but the first line of a file
cat ${r} | tail -n +2 >> ${rep_out}
done

## should be 298 -> 149 replicating peaks * 2 replicates
## 298
cat ${rep_out} | tail -n +2 | wc -l
## inspect output
column -t -s "," ${rep_out}
#+END_SRC

* Wilcoxon Rank Test for Number of QTLs in Arg/N-End Vs Ac/N-End Pathway  :R:

#+BEGIN_SRC R

## -----
## ifelse to determine which system we're on
## if not on home machine, assume msi
system   <- Sys.info()["nodename"]
base_dir <- "~/data/illumina/"
## determine if we're on msi; set wd appropriately
base_dir <- ifelse(system != "mahlon-linux",
                   "/home/albertf/mahlon/data/illumina/",
                   base_dir)
table_dir  <- "2021.10.30_all_UPS_rdata/peaks/merged_delta_AF_peak_tables/"
table_file <- "averaged_merged_all_peaks_table.csv"
avg_table <- read.csv(file = paste0(base_dir,
                                    table_dir,
                                    table_file),
                      header = T, sep = ",",
                      quote = "")

path_test <- function(x) {
    ifelse(x == "Ala" | x == "Cys" | x == "Gly" |
           x == "Met" | x == "Pro" | x == "Ser" |
           x == "Thr" | x == "Val",
           "Ac/N-end Pathway", "Arg/N-end Pathway")
}

avg_table$path <- path_test(x = gsub(pattern = "_.*",
                                     replacement = "",
                                     as.character(avg_table$reporter)))

avg_table$path_factor <- as.factor(avg_table$path)

## does one pathway have a significantly greater effect size? 
median(abs(avg_table$delta_AF[avg_table$path == "Arg/N-end Pathway"]))
median(abs(avg_table$delta_AF[avg_table$path == "Ac/N-end Pathway"]))

wilcox.test(x = abs(avg_table[avg_table$path == "Ac/N-end Pathway", "delta_AF"]),
            y = abs(avg_table[avg_table$path == "Arg/N-end Pathway", "delta_AF"]),
            alternative = "two.sided",
            exact = T,
            conf.level = 0.95)

wilcox.test(x = abs(avg_table[avg_table$path == "Ac/N-end Pathway", "LOD"]),
            y = abs(avg_table[avg_table$path == "Arg/N-end Pathway", "LOD"]),
            alternative = "two.sided",
            exact = T,
            conf.level = 0.95)

frac <- vector()
nqtls <- vector()
for(i in 1:length(unique(levels(avg_table$reporter)))) {
    r_frame <- avg_table[avg_table$reporter == unique(levels(avg_table$reporter))[i], ]
    nqtls[i] <- nrow(r_frame)
    reporter <- unique(levels(avg_table$reporter))
}

out <- data.frame(nqtls = nqtls,
                  reporter = reporter)

out$reporter <- gsub(pattern = "_TFT",
                     replacement = "",
                     x = out$reporter)

out$path <- path_test(out$reporter)

out

wilcox.test(x = out[out$path == "Ac/N-end Pathway", "nqtls"],
            y = out[out$path == "Arg/N-end Pathway", "nqtls"],
            alternative = "two.sided",
            exact = T,
            conf.level = 0.95)

median(out[out$path == "Ac/N-end Pathway", "nqtls"])
median(out[out$path == "Arg/N-end Pathway", "nqtls"])


#+END_SRC

* Reporters per QTL Plot (QTL Pathway-Specificity Analysis)               :R:

#+BEGIN_SRC R :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/pathway_specificity_histogram.R
## -----
## code to analyze how many reporters per QTL we see


## -----
## setup
library("lattice")
library("latticeExtra")
library("RColorBrewer")
library("grid")
library("VariantAnnotation")
source("~/QTL_scripts/gTest.R")
source("~/QTL_scripts/x_qtl_seq_functions_170831.R")
source("~/QTL_scripts/mp_JB_170901.R")
source("~/QTL_scripts/peaksFromVector.R")
load("~/QTL_scripts/chr_labels.Rdata")
hist_colors <- c(gray(0.5), gray(0.9))

## -----
## ifelse to determine which system we're on
## if not on home machine, assume msi
system   <- Sys.info()["nodename"]
base_dir <- "~/data/illumina/"
## determine if we're on msi; set wd appropriately
base_dir <- ifelse(system != "mahlon-linux",
                   "/home/albertf/mahlon/data/illumina/",
                   base_dir)
table_dir  <- "2021.10.30_all_UPS_rdata/peaks/merged_delta_AF_peak_tables/"
table_file <- "averaged_merged_all_peaks_table.csv"
avg_table <- read.csv(file = paste0(base_dir,
                                    table_dir,
                                    table_file),
                      header = T, sep = ",",
                      quote = "")

## -----
## calculate the median number of QTLs per reporter
reporter_list <- list()
for (i in 1:length(unique(avg_table$reporter))) {
    reporter <- levels(avg_table$reporter)[i]
    out <- avg_table[avg_table$reporter == reporter, ]
    reporter_list[[i]] <- nrow(out)
}
reporter_list <- do.call("rbind", reporter_list)
median(reporter_list)
## median n. QTLs per reporter = 7

## -----
## <<heatmap_setup>>
## build a dummy dataframe to drop QTLs into
## ~120 bins if you use 100 kb windows for the map

## read in chr lengths
## need this for building the heatmap
chr_lengths <- read.table("~/QTL_scripts/sacCer3ChromLengths.txt", header = F)

## don't need mitochondrial chromosome
chr_lengths <- chr_lengths[1:16, ]

## add the gcoords and numeric (not roman) chromosomes:
chr_lengths$chr <- 1:16
chr_lengths$gcoords <- getGcoords(chr = 1:16,
                                  pos = chr_lengths$chr,
                                  spacing = 0)
chr_lengths <- chr_lengths[, c(3, 1, 2, 4)]
names(chr_lengths) <- c("chr", "chr_r", "length", "gcoords")

## <<build_heatmap_dataframe>>
k <- 1
reporters <- levels(avg_table$reporter)

final <- list()
for (k in 1:length(reporters)) {

## make a list of 16 containing the chr and bin as a dataframe
## have to round up the chr lengths so the bins are all the same
## size (1e5 bp)

## we need to make an extra bin for ea. chromosome, since the
## lengths don't end in 1e5 multiples.  'round_up' allows you
## to do this using a multiple of your choice.
## So, chrI = 230218 bp and round_up(230218, 1e5) = 3e5
round_up <- function(from, to) {
    ceiling(from / to) * to
    }

round_down <- function(from, to) {
    floor(from / to) * to
    }

## assign each bin to the correct chromosome
chr_indices <- unlist(sapply(X = 1:16, FUN = function(x) {
                                 rep(x,
                                     times = length(seq(from = 1e5,
                                                        to = round_up(chr_lengths$length[x],
                                                                      to = 1e5),
                                                        by = 1e5)))
                      }))

## create chromosome bins - this will serve as a conditioning factor
bins <- seq(from = 1e5,
            to = length(chr_indices) * 1e5,
            by = 1e5)

## when we assign peaks to bins, we need to add the length of
## all preceding chromosomes plus the peak position.  we'll use
## the bin lengths, not the chromosome lengths for this purpose.
## so, a QTL on chrII at base 150 = 3e5 (length of chr I bins) + 150
bin_sums <- c(0, unlist(sapply(X = 2:16, FUN = function(x) {
                              max(bins[chr_indices == x - 1])
                              })))

## assign the peaks for ea. reporter to a dataframe
out <- avg_table[avg_table$reporter == reporters[k], ]

## assign each peak a bin for the heatmap
for (b in 1:nrow(out)) {
    out$bin[b] <- round_down(from = out$max_Index[b] + bin_sums[out$chr[b]],
                             to = 1e5)
}

## dummy dataframe that contains all bins
chr_bins <- data.frame(reporter = rep(reporters[k], length(bins)),
                       chr = chr_indices,
                       LOD = rep(0, length(bins)),
                       delta_AF = rep(0, length(bins)),
                       left_Index = rep(0, length(bins)),
                       max_Index = rep(0, length(bins)),
                       right_Index = rep(0, length(bins)),
                       bin = bins)

## the bins above aren't exact, so assign them to one
## of the bins we defined using 'which.min'
## assign peaks to bins via 'which.min'
for (r in 1:nrow(out)) {
    ind <- out$chr[r]
    chrs <- chr_bins$bin[chr_bins$chr == ind & chr_bins$bin > out$bin[r]]
    out$bin[r] <- chrs[which.min(abs(out$bin[r] - chrs))]
}

## if there's a peak, replace the current row with the peak row
## if not, just leave everything at 0
for (n in 1:nrow(chr_bins)) {
    test <- min(abs(chr_bins[n, "bin"] - out$bin))
    ind  <- which.min(abs(chr_bins[n, "bin"] - out$bin))
    chr_bins[n, ] <- if(test == 0) out[ind, ] else chr_bins[n, ]
}

## assign the dataframe w/ each peak and peak bin position to a list
## that we'll collapse after we've run through all the reporters
final[[k]] <- chr_bins
}

## collapse output to a single frame
peaks <- do.call("rbind", final)

## remove any bins that don't contain a peak
peaks_final <- peaks[peaks$LOD > 0, ]

## simplify the reporter variable w/ 'gsub'
peaks_final$aa <- gsub(pattern = "_TFT",
                 replacement = "",
                 x = peaks_final$reporter)
peaks_final$aa <- as.factor(peaks_final$aa)

## add in the pathways
path_test <- function(x) {
    ifelse(x == "Ala" | x == "Cys" | x == "Gly" |
           x == "Met" | x == "Pro" | x == "Ser" |
           x == "Thr" | x == "Val",
           "Ac/N-end Pathway", "Arg/N-end Pathway")
}
peaks_final$pathway <- path_test(peaks_final$aa)
peaks_final$pathway <- as.factor(peaks_final$pathway)

## make sure the output matches the delta_AF heatmap:
mark <- unique(peaks_final$bin)
ord <- order(mark)
mark <- mark[ord]
mark_out <- vector()
mark_chr <- vector()
for (i in 1:length(mark)) {
    mark_out[i] <- nrow(peaks_final[peaks_final$bin == mark[i], ])
    mark_chr[i] <- unique(peaks_final$chr[peaks_final$bin == mark[i]])
}
## rbind(mark_chr, mark_out)
##          [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
## mark_chr    1    2    2    2    4    4    4    4    4     4     5     7     7
## mark_out    7    1    3    2    3    1    1    1    6     1     7     1     7
##          [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24]
## mark_chr     7     7     7     8     8     9     9    10    10    10    10
## mark_out     2     9     8     1     2     2     6    10     1     1     4
##          [,25] [,26] [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35]
## mark_chr    11    11    11    11    12    12    12    12    13    13    13
## mark_out     1     2     2     1     1     1    14     1     3     3     3
##          [,36] [,37] [,38] [,39] [,40] [,41] [,42] [,43]
## mark_chr    14    15    15    15    15    16    16    16
## mark_out    10     8     2     1     3     1     4     1

## now, individual pathways
arg_peaks_final <- peaks_final[peaks_final$pathway == "Arg/N-end Pathway", ]
arg_mark <- unique(arg_peaks_final$bin)
arg_ord <- order(arg_mark)
arg_mark <- arg_mark[arg_ord]
arg_mark_out <- vector()
arg_mark_chr <- vector()
for (i in 1:length(arg_mark)) {
    arg_mark_out[i] <- nrow(arg_peaks_final[arg_peaks_final$bin == arg_mark[i], ])
    arg_mark_chr[i] <- unique(arg_peaks_final$chr[arg_peaks_final$bin == arg_mark[i]])
}
## rbind(arg_mark_chr, arg_mark_out)
##              [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
## arg_mark_chr    2    2    4    4    4    4    4    7    7     7     8     8
## arg_mark_out    1    3    3    1    1    2    1    1    4     8     1     2
##              [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23]
## arg_mark_chr     9    10    10    10    10    11    11    12    12    13    13
## arg_mark_out     2     5     1     1     2     1     2     6     1     2     3
##              [,24] [,25] [,26]
## arg_mark_chr    13    14    15
## arg_mark_out     3     7     7


ac_peaks_final <- peaks_final[peaks_final$pathway == "Ac/N-end Pathway", ]
ac_mark <- unique(ac_peaks_final$bin)
ac_ord <- order(ac_mark)
ac_mark <- ac_mark[ac_ord]
ac_mark_out <- vector()
ac_mark_chr <- vector()
for (i in 1:length(ac_mark)) {
    ac_mark_out[i] <- nrow(ac_peaks_final[ac_peaks_final$bin == ac_mark[i], ])
    ac_mark_chr[i] <- unique(ac_peaks_final$chr[ac_peaks_final$bin == ac_mark[i]])
}

## rbind(ac_mark_chr, ac_mark_out)
##             [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
## ac_mark_chr    1    2    4    4    5    7    7    7    9    10    10    11
## ac_mark_out    7    2    1    4    7    7    2    5    6     5     2     2
##             [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23]
## ac_mark_chr    11    12    12    12    13    14    15    15    15    15    16
## ac_mark_out     1     1     1     8     1     3     1     2     1     3     1
##             [,24] [,25]
## ac_mark_chr    16    16
## ac_mark_out     4     1

all_peaks_out <- data.frame(peaks = mark_out, chr = mark_chr)
all_peaks_out$path <- rep(x = "All", times = nrow(all_peaks_out))

arg_peaks_out <- data.frame(peaks = arg_mark_out, chr = arg_mark_chr)
arg_peaks_out$path <- rep(x = "Arg/N-end Pathway", times = nrow(arg_peaks_out))

ac_peaks_out <- data.frame(peaks = ac_mark_out, chr = ac_mark_chr)
ac_peaks_out$path <- rep(x = "Ac/N-end Pathway", times = nrow(ac_peaks_out))

per_q <- list()
per_q[[1]] <- all_peaks_out
per_q[[2]] <- ac_peaks_out
per_q[[3]] <- arg_peaks_out
per_q_final <- do.call("rbind", per_q)
per_q_final$path_factor <- factor(per_q_final$path,
                                  levels = c("All",
                                             "Ac/N-end Pathway",
                                             "Arg/N-end Pathway"),
                                  labels = c("All",
                                             "Ac/N-end Pathway",
                                             "Arg/N-end Pathway"))

per_q_breaks <- seq(from = 0, to = 15, by = 1)
per_q_colors <- c(gray(0.5), gray(0.7), gray(0.9))
per_q_hist <- histogram(~ peaks | path_factor,
                      type = "count",
                      data = per_q_final,
                      xlim = c(0, 15),
                      ylim = c(0, 18),
                      layout = c(3, 1),
                      xlab = "Reporters per QTL",
                      scales = list(x = list(at = seq(from = 0.5, to = 14.5, by = 1),
                                             labels = as.character(1:15)),
                                    y = list(at = seq(from = 0, to = 20, by = 1)),
                                    alternating = F,
                                    tck = c(1, 0)),
                      breaks = per_q_breaks,
                      par.strip.text = list(cex = 1.7),
                      par.settings = list(strip.background = list(col = gray(0.9)),
                                          axis.text = list(cex = 1.5),
                                          par.ylab.text = list(cex = 1.8),
                                          par.xlab.text = list(cex = 1.8)
                                          ),
                      panel = function(x, ..., col) {
                          panel.histogram(x, ..., col = per_q_colors[packet.number()])
                      }
                      )
print(per_q_hist)

pdf(file = paste0("/home/mahlon/emacs/N-end_Rule_QTL_paper/figures_drafts/",
                  "supplementary_figure_004_reporters_per_QTL.pdf"),
    width = 15)
print(per_q_hist)
dev.off()


## -----
## compare RM enriched vs. RM depleted QTLs
pos_neg <- list()
for (i in 1:length(levels(avg_table$reporter))) {
    reporter <- levels(avg_table$reporter)[i]
    dat <- avg_table[avg_table$reporter == reporter, ]
    pos <- nrow(dat[dat$delta_AF > 0, ])
    neg <- nrow(dat[dat$delta_AF < 0, ])
    frac <- pos / (pos + neg)
    pos_neg[[i]] <- frac
}
pos_neg_out <- do.call("rbind", pos_neg)
pos_neg_out <- data.frame(frac = pos_neg_out,
                          reporter = levels(avg_table$reporter))

## for 15 reporters, RM allele associated w/ higher UPS activity
nrow(pos_neg_out[pos_neg_out$frac > 0.5, ])

## 89 of 149 peaks RM allele associated w/ higher UPS activity
nrow(avg_table[avg_table$delta_AF > 0, ]) / 149

avg_table[avg_table$path == "Ac/N-end Pathway" & avg_table$chr == 1, ]
avg_table[avg_table$path == "Ac/N-end Pathway" &
          avg_table$chr == 7 &
          avg_table$max_Index < 250000, ]
#+END_SRC

* 'ecdf' Plot of Replicating QTLs by Pathway                              :R:

#+BEGIN_SRC R :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/QTL_ecdf_plots.R
## -----
## cdf plot of QTLs
s
## -----
## setup
library("lattice")
library("latticeExtra")
library("RColorBrewer")
library("grid")
library("VariantAnnotation")


## -----
## read in peaks
base_dir <- "~/data/illumina/"
table_dir  <- "2021.10.30_all_UPS_rdata/peaks/merged_delta_AF_peak_tables/"
table_file <- "averaged_merged_all_peaks_table.csv"
avg_table <- read.csv(file = paste0(base_dir,
                                    table_dir,
                                    table_file),
                      header = T, sep = ",",
                      quote = "")
str(avg_table) ; nrow(avg_table)


## -----
## sort peaks by pathway
path_test <- function(x) {
    ifelse(x == "Ala_TFT" | x == "Cys_TFT" | x == "Gly_TFT" |
           x == "Met_TFT" | x == "Pro_TFT" | x == "Ser_TFT" |
           x == "Thr_TFT" | x == "Val",
           "Ac/N-end Pathway", "Arg/N-end Pathway")
}


## create Ac/ vs. Arg/N-end pathway variable
avg_table$path <- path_test(avg_table$reporter)
avg_table$path <- as.factor(avg_table$path)
nrow(avg_table[avg_table$path == "Arg/N-end Pathway", ])
nrow(avg_table[avg_table$path == "Ac/N-end Pathway", ])

pdf(file = paste0("~/emacs/N-end_Rule_QTL_paper/figures_drafts/",
                  gsub(pattern = " .*",
                       replacement = "",
                       x = Sys.time()),
                  "_delta_AF_ecdf.pdf"))

## "~/emacs/N-end_Rule_QTL_paper/figures_drafts/QTL_ecdf_by_pathway.pdf",
##     width = 10, height = 5)

print(
ecdfplot(~ delta_AF,
         groups = path,
         data = avg_table,
         col = c("#6699CC", "#AA4499"),
         lwd = 1.5,
         xlim = c(-0.75, 0.75),
         ylim = c(-0.1, 1.05),
         xlab = expression(paste("Effect Size (", Delta, "RM Allele Frequency)")),
         ylab = "Cumulative Density",
         key = list(## corner = c(0.005, 0.935),
                    lines = list(size = 3.5,
                                 lwd = 3.5,
                                 col = c("#AA4499", "#6699CC")),
                    text = list(labels = c("Arg/N-end Pathway",
                                           "Ac/N-end Pathway"),
                                cex = 1.7),
                    padding.text = 2.5),
         scales = list(x = list(at = seq(from = -0.7, to = 0.7, by = 0.20),
                                labels = sprintf("%.1f", seq(from = -0.7, to = 0.7, by = 0.20)),
                                cex = 1.7),
                       y = list(at = seq(from = 0, to = 1, by = 0.2),
                                cex = 1.7),
                       tck = c(1, 0)),
         par.settings = list(par.ylab.text = list(cex = 1.7),
                             par.xlab.text = list(cex = 1.7)),
         panel = function(...) {
             panel.abline(h = 0.5, v = 0,
                          lwd = 1,
                          col = gray(0.5),
                          lty = 2)
             panel.ecdfplot(...)
             panel.abline(h = c(0, 1), col = gray(0.7))
             panel.text(c("RM allele = Lower UPS Activity",
                          "RM allele = Higher UPS Activity"),
                        x = c(-0.375, 0.375),
                        y = c(-0.05, -0.05),
                        cex = 1.2)
             ## panel.arrows(x1 = -0.74, x2 = -0.5,
             ##              y1 = -0.05, y2 = -0.05,
             ##              length = 0.08,
             ##              col = gray(0.4))
             ## panel.arrows(x1 = -0.01, x2 = -0.165,
             ##              y1 = -0.05, y2 = -0.05,
             ##              length = 0.08,
             ##              col = gray(0.4))
             ## panel.arrows(x1 = 0.74, x2 = 0.5,
             ##              y1 = -0.05, y2 = -0.05,
             ##              length = 0.08,
             ##              col = gray(0.4))
             ## panel.arrows(x1 = 0.01, x2 = 0.165,
             ##              y1 = -0.05, y2 = -0.05,
             ##              length = 0.08,
             ##              col = gray(0.4))
}
)
)
dev.off()


pdf(file = paste0("~/emacs/N-end_Rule_QTL_paper/figures_drafts/",
                  gsub(pattern = " .*",
                       replacement = "",
                       x = Sys.time()),
                  "_LOD_ecdf.pdf"))
print(
ecdfplot(~ LOD,
         groups = path,
         data = avg_table,
         col = c("#6699CC", "#AA4499"),
         lwd = 1.5,
         xlim = c(-5, 255),
         ylim = c(-0.05, 1.05),
         xlab = "LOD",
         ylab = "Cumulative Density",
         key = list(## corner = c(0.005, 0.999),
                    lines = list(size = 3.5,
                                 lwd = 3.5,
                                 col = c("#AA4499", "#6699CC")),
                    text = list(labels = c("Arg/N-end Pathway",
                                           "Ac/N-end Pathway"),
                                cex = 1.7),
                    padding.text = 2.5),
         scales = list(x = list(at = seq(from = 0, to = 250, by = 25),
                                labels = as.character(seq(from = 0, to = 250, by = 25)),
                                cex = 1.7),
                       y = list(at = seq(from = 0, to = 1, by = 0.2),
                                cex = 1.7),
                       tck = c(1, 0)),
         par.settings = list(par.ylab.text = list(cex = 1.7),
                             par.xlab.text = list(cex = 1.7)),
         panel = function(...) {
             ## panel.abline(h = 0.5, v = 0,
             ##              lwd = 1,
             ##              col = gray(0.7),
             ##              lty = 2)
             ## panel.abline(h = c(0, 1), col = gray(0.2))
             panel.ecdfplot(...)
             panel.abline(h = c(0, 1), col = gray(0.7))             
             ## panel.text(c("RM allele = Lower UPS Activity",
             ##              "RM allele = Higher UPS Activity"),
             ##            x = c(-0.25, 0.25),
             ##            y = c(-0.05, -0.05),
             ##            cex = 1.2)
             ## panel.arrows(x1 = -0.74, x2 = -0.5,
             ##              y1 = -0.05, y2 = -0.05,
             ##              length = 0.08,
             ##              col = gray(0.4))
             ## panel.arrows(x1 = -0.01, x2 = -0.165,
             ##              y1 = -0.05, y2 = -0.05,
             ##              length = 0.08,
             ##              col = gray(0.4))
             ## panel.arrows(x1 = 0.74, x2 = 0.5,
             ##              y1 = -0.05, y2 = -0.05,
             ##              length = 0.08,
             ##              col = gray(0.4))
             ## panel.arrows(x1 = 0.01, x2 = 0.165,
             ##              y1 = -0.05, y2 = -0.05,
             ##              length = 0.08,
             ##              col = gray(0.4))
}
))
dev.off()
#+END_SRC

* Binomial Test for Significant Enrichment of RM Allele in QTLs           :R:

#+BEGIN_SRC R
## for 89 QTLs, the RM allele was associated w/ higher UPS activity
binom.test(x = 89, n = 149, p = 0.5)
## Exact binomial test
## data:  89 and 149
## number of successes = 89, number of trials = 149, p-value = 0.02148
## alternative hypothesis: true probability of success is not equal to 0.5
## 95 percent confidence interval:
##  0.5139243 0.6767566
## sample estimates:
## probability of success
##              0.5973154

base_dir <- "~/data/illumina/"
table_dir  <- "2021.10.30_all_UPS_rdata/peaks/merged_delta_AF_peak_tables/"
table_file <- "averaged_merged_all_peaks_table.csv"
avg_table <- read.csv(file = paste0(base_dir,
                                    table_dir,
                                    table_file),
                      header = T, sep = ",",
                      quote = "")

## -----
## fraction of reporters w/ more RM = higher UPS activity QTLs

## assign reporter to Arg/N-end or Ac/N-end pathway
path_test <- function(x) {
    ifelse(x == "Ala" | x == "Cys" | x == "Gly" |
           x == "Met" | x == "Pro" | x == "Ser" |
           x == "Thr" | x == "Val",
           "Ac/N-end Pathway", "Arg/N-end Pathway")
}

frac <- vector()
nqtls <- vector()
for(i in 1:length(unique(levels(avg_table$reporter)))) {
    r_frame <- avg_table[avg_table$reporter == unique(levels(avg_table$reporter))[i], ]
    nqtls[i] <- nrow(r_frame)
    reporter <- unique(levels(avg_table$reporter))
}

out <- data.frame(nqtls = nqtls,
                  reporter = reporter)

out$reporter <- gsub(pattern = "_TFT",
                     replacement = "",
                     x = out$reporter)
out$path <- path_test(out$reporter)

t.test(x = out[out$path == "Ac/N-end Pathway", "nqtls"],
       y = out[out$path == "Arg/N-end Pathway", "nqtls"],
       alternative = "two.sided")
median(out[out$path == "Ac/N-end Pathway", "nqtls"])
median(out[out$path == "Arg/N-end Pathway", "nqtls"])

## -----
## misc.

## n. reporters w/ > 3 QTLs
nrow(out[out$nqtls >= 3, ]) ## 18

## n. reporters w/ > 3 QTLs and > 0.5 RM = higher activity fraction
nrow(out[out$nqtls >= 3 & out$frac > 0.5, ]) ## 14

## 14 / 18 => 0.78

#+END_SRC

* TFT Sort Plot                                                           :R:

#+BEGIN_SRC R :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/TFT_sort_plot.R
## -----
##############
## USER INPUT:
##############

## the only things that should need to be changed for this script to work
## no trailing '/' at the end!
base_dir <- "~/data/flow/2021.01.20_sort_figure"
setwd(base_dir)
needed_dirs <- c("/fcs", "/results", "/tables", "/scripts")
dir_maker <- function(x){
    ifelse(!dir.exists(paths = paste0("./", x)),
           dir.create(path = paste0("./", x)),
           paste0("dir ", paste0(getwd(), x), " exists_"))
}
sapply(X = needed_dirs, FUN = dir_maker)
work_dir       <- paste0(base_dir, "/fcs")
results_dir    <- paste0(base_dir, "/results")
tables_dir     <- paste0(base_dir, "/tables")

## -----
## <<Required_Packages>>
## check for Bioconductor and install if not available
ifelse(!requireNamespace("BiocManager", quietly = TRUE),
       install.packages("BiocManager",
                        dependencies = TRUE,
                        repos = "http://cran.wustl.edu/",
                        quiet = TRUE),
       paste0("Bioconductor available"))
require("BiocManager")


## -----
## load packages or install if not available
## have to split these out by bioconductor vs. non-bioconductor
## non-bioconductor
package_installer <- function(x){
    if(!requireNamespace(x, quietly = TRUE))
        install.packages(x, dependencies = TRUE,
                         repos = "http://cran.wustl.edu/",
                         quiet = TRUE, INSTALL_opts = '--no-lock')}
packages <- c("colorspace", "lattice", "ggvis", "dygraphs", "DescTools", "viridis")
sapply(X = packages, FUN = package_installer)
sapply(X = packages, FUN = require, character.only = TRUE)


## -----
## bioconductor
bioc_package_installer <- function(x){if(!requireNamespace(x))
                                          BiocManager::install(x, INSTALL_opts = '--no-lock')}
bioc_packages <-  c("flowCore", "flowViz", "flowUtils", "flowStats", "flowFP", "geneplotter", "ggcyto")
sapply(X = bioc_packages, FUN = bioc_package_installer)
sapply(X = bioc_packages, FUN = require, character.only = TRUE)


## -----
## required for merging flowsets into a single flowframe
source(file = "https://raw.githubusercontent.com/mac230/flow_scripts/master/set2frame.R")


## -----
## read in the data
dat <- read.flowSet(path = work_dir,
                    min.limit = 1,
                    alter.names = T)

##-----
## <<TFT_Transformation>>
## use the transform function to get the TFT/PSV parameters we want
## start by converting 0's in fluors to 1's via truncate transform
trunc.trans   <- truncateTransform("Convert 0's to 1's.", a = 1)
trunc.fluors  <- function(x){
    transform(x,
              `GFP.A` = trunc.trans(`GFP.A`),
              `mCherry.A` = trunc.trans(`mCherry.A`))}
dat <- fsApply(x = dat, FUN = trunc.fluors)

PSV.TFT.transform <- function(x){
    transform(x,
              `log_GFP` = log10(`GFP.A`),
              `log_RFP` = log10(`mCherry.A`),
              `TFT_ratio` = log(`mCherry.A`/`GFP.A`, base = 2),
              `PSV_ratio` = log(`GFP.A`/`mCherry.A`, base = 2),
              ## 'no log' TFT ratio
              `nl_TFT_ratio` = (`mCherry.A`/`GFP.A`)
              )}

dat <- fsApply(x = dat, FUN = PSV.TFT.transform)

trunc.gfp <- truncateTransform("make set GFP positive", a = 2.5)
trunc.gfp.f <-  function(x){
    transform(x,
              `log_GFP` = trunc.gfp(`log_GFP`))}

dat <- fsApply(x = dat, FUN = trunc.gfp.f)

## -----
## <<FSC_Gate>>
## a function to gate the cells to include only haploids.
## we identify these as a sharp peak in the lower end of
## the fsc density plot.  I take 10% above and below the
## max density value
fsc.gate.generator <- function(x){
    fsc.dens  <- density(exprs(x[, 1]))
    ## return the index of the maximum y value of the density estimate
    fsc.max   <- fsc.dens[[1]][which.max(fsc.dens[[2]])]
    fsc.upper <- (fsc.max * 0.25) + fsc.max
    fsc.lower <- fsc.max - (fsc.max * 0.25)
    fsc.gate  <- c(fsc.lower, fsc.upper)
}

curv.split <- function(x){
    split(x, f = rectangleGate("FSC.A" = fsc.gate.generator(x)),
          population = "defaultRectangleGate+",
          flowSet = T, codeflowSet = T)}
curv.set <- fsApply(x = dat, FUN = curv.split)


tft.gate.generator <- function(x){
    tft.dens  <- density(exprs(x[, 15]))
    ## return the index of the maximum y value of the density estimate
    tft.max   <- tft.dens[[1]][which.max(tft.dens[[2]])]
    tft.upper <- (tft.max * 0.025) + tft.max
    tft.lower <- tft.max - (tft.max * 0.025)
    tft.gate  <- c(tft.lower, tft.upper)
}

tft.gate.generator(curv.set[[1]][[1]])

dat_f <- as.data.frame(exprs(dat[[1]]))
high_FSC <- quantile(x = dat_f$FSC.A, probs = 0.70)
low_FSC <- quantile(x = dat_f$FSC.A, probs = 0.30)

dat_g <- dat_f[dat_f$FSC.A > low_FSC & dat_f$FSC.A < high_FSC, ]

## 'high_TFT' = high UPS activity, so low TFT ratio
low_col <- "#ec6ab7ff"
high_col <-  "#5AC168ff"

low_t_col <- "#ec6ab722"
high_t_col <-  "#5AC16811"

dat_g <- dat_g[dat_g$log_GFP > 2.6, ]

high_TFT_val <- quantile(x = dat_g$TFT_ratio, probs = 0.02)
low_TFT_val  <- quantile(x = dat_g$TFT_ratio, probs = 0.98)


{
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/TFT_sort_density_plot_gate_shading.pdf")
print(
densityplot(dat_g$TFT_ratio,
            plot.points = F,
            xlab = expression("log"["2"]*" RFP / GFP"),
            key = list(lines = list(col = c(low_col,
                                            high_col),
                                    lty = 2,
                                    lwd = 4),
                       text = list(labels = c("2% Low UPS activity gate",
                                              "2% High UPS activity gate"),
                                   cex = 2)),
            scales = list(tck = c(1, 0),
                          x = list(cex = 2,
                                   at = -4:1),
                          y = list(cex = 2)),
            xlim = c(-5, 2),
            col = gray(0.1),
            par.settings = list(par.xlab.text = list(cex = 2),
                                par.ylab.text = list(cex = 2)),
            lwd = 2,
            panel = function(...) {
                panel.densityplot(...)
                panel.abline(v = c(high_TFT_val,
                                   low_TFT_val),
                             col = c(high_col,
                                     low_col),
                             lwd = 4, lty = 2)
                panel.abline(h = 0,
                             col = gray(0.9),
                             lwd = 2)
})
)
## comment this out to get rid of the shading
grid.rect(x = c(0.27, 0.850),
          y = c(0.505, 0.505),
          width = c(0.22, 0.21),
          height = c(0.707, 0.707),
          default.units = "npc",
          draw = T,
          gp = gpar(col = c(low_t_col, high_t_col),
                    fill = c(low_t_col, high_t_col))
)
dev.off()
}

high_TFT <- dat_g[dat_g$TFT_ratio <= high_TFT_val, ]
low_TFT <- dat_g[dat_g$TFT_ratio >= low_TFT_val, ]


## -----
## plot
## 2021.10.06 - update to no longer plot neg. ctrl.
{
pdf("~/emacs/N-end_Rule_QTL_paper/figures_drafts/TFT_sort_xy_plot.pdf")
print(
xyplot(log_RFP ~ log_GFP,
       data = dat_g,
       type = c("p", "g"),
       xlim = c(1.5, 4.5),
       ylim = c(1.5, 4.5),
       pch = 19,
       col = gray(0.3, alpha = 0.2),
       cex = 0.25,
       xlab = expression("log"["10"]*" GFP"),
       ylab = expression("log"["10"]*" RFP"),
       key = list(lines = list(col = c(low_col,
                                       high_col),
                               lwd = 10,
                               size = 2.5),
                  text = list(labels = c("2% Low UPS Activity Gate",
                                         "2% High UPS Activity Gate"),
                                         cex = 2),
                                         corner = c(0.02, 0.98)),
       scales = list(tck = c(1, 0),
                     alternating = F,
                     x = list(cex = 2),
                     y = list(cex = 2)),
       par.settings = list(par.ylab.text = list(cex = 2),
                           par.xlab.text = list(cex = 2)),
       panel = function(...) {
           panel.xyplot(...)
           panel.points(x = high_TFT$log_GFP, y = high_TFT$log_RFP,
                        pch = 19, col = high_col, cex = 0.25)
           panel.points(x = low_TFT$log_GFP, y = low_TFT$log_RFP,
                        pch = 19, col = low_col, cex = 0.25)
}
))
grid.text(label = c("20,000 cells",
                    "each collected",
                    "from high and low",
                    "UPS activity gates"),
          x = c(0.31, 0.335, 0.37, 0.375),
          y = c(0.80, 0.75, 0.70, 0.65),
          rot = 0,
          default.units = "npc",
          gp = gpar(col = "black",
                    cex = 2,
                    just = "left"))
dev.off()
}

#+END_SRC

* 'auto_process_N-End_fcs_files.R'                                 :R:HELPER:

#+BEGIN_SRC R :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/auto_process_N-end_fcs_files.R
## -----
## load all required packages
source("~/emacs/R/functions/load_flow_packages.R")

needed_dirs <- c("/fcs", "/results", "/tables",
                 "/scripts", "/dataframes", "/sessions",
                 "/dataframes/gated", "/dataframes/ungated")

dir_maker <- function(x){
    ifelse(!dir.exists(paths = paste0(base_dir, x)),
           dir.create(path = paste0(base_dir, x)),
           paste0("dir ", paste0(base_dir, x), " exists."))
}

sapply(X = needed_dirs, FUN = dir_maker)
work_dir       <- paste0(base_dir, "/fcs")
results_dir    <- paste0(base_dir, "/results")
tables_dir     <- paste0(base_dir, "/tables")
sessions_dir   <- paste0(base_dir, "/sessions")
frame_dir      <- paste0(base_dir, "/dataframes")
gated_dir      <- paste0(frame_dir, "/gated/")
ungated_dir    <- paste0(frame_dir, "/ungated/")
out_log        <- paste0(results_dir, "/output_log")


## -----
## read in all the fcs files in a directory 
all_flow <- read.flowSet(files = NULL,
                         path = work_dir,
                         pattern = ".*.fcs",
                         alter.names = T,
                         min.limit = 2)

 
## get the number of cells per file; write output
cells_per_file <- fsApply(x = all_flow,
                          FUN = function(x) {
                              nrow(as.data.frame(exprs(x))) 
                          })

## write information string to the output log
read_string <- paste0("1. On ",
                      Sys.time(),
                      " files were read in via 'read.flowSet'.\n\nCells per file:\n")

write(x = read_string,
      file = out_log,
      append = F)

## for nicely aligned output in the resulting file
cat(capture.output(cells_per_file),
    file = out_log,
    append = T,
    sep = "\n")

all_filtered <- all_flow

## -----
## now convert flowframes to dataframes and merge to a single frame
## start w/ ungated cells
ungated_frames <- fsApply(x = all_filtered,
                          FUN = function(x) {
                              
                              ## extract file name; we'll
                              ## add this to the dataframe
                              file_name <- rep(x = x@description$GUID,
                                               times = nrow(as.data.frame(exprs(x))))
                              
                              ## extract the time the sample was run;
                              ## then convert to a numeric value
                              ## BTIM = "beginning time"
                              file_time <- rep(x = x@description$`$BTIM`,
                                               times = nrow(as.data.frame(exprs(x))))
                              time_conv <- HmsToSec(file_time)
                              
                              ## combine flow data and file name
                              ## into a single data frame 
                              cbind(as.data.frame(exprs(x)),
                                    file_name,
                                    file_time,
                                    time_conv)
})

ungated_final <- do.call("rbind", ungated_frames)


## -----
## log fluorescence values and compute TFT ratio
ungated_final$log_GFP   <- log10(x = ungated_final$eGFP.A)
ungated_final$log_RFP   <- log10(x = ungated_final$mCherry.A)
ungated_final$TFT_ratio <- -log(x = ungated_final$log_RFP / ungated_final$log_GFP,
                                base = 2)

## unique(is.na(ungated_final$TFT_ratio))


## -----
## now gate the cells to capture the haploid cell population.
## we identify haploids as a sharp peak in the lower end of
## the fsc density plot.  I take 10% above and below the
## max density value.
ungated_final$file_string <- as.character(ungated_final$file_name)

## ungated = all cells
ungated_final$ungated <- rep(T, nrow(ungated_final))

## gated = all cells w/in 10% +/- FSC max density
densities <- lapply(X = unique(ungated_final$file_string),
                    FUN = function(x) {
                        
                        ## file name for dataframe creation
                        f_name <- x

                        ## per file dataframe for calculating density
                        dat  <- ungated_final[ungated_final$file_name == f_name, ]
                        
                        ## get the density for FSC
                        dens <- density(dat$FSC.A)
                        
                        ## 10% +/- the max FSC density peak
                        dens_max <- dens$x[which.max(dens$y)]
                        dens_up <- (0.1 * dens_max) + dens_max
                        dens_down <- dens_max - (0.1 * dens_max)
                        data.frame(f_name, dens_up, dens_down, stringsAsFactors = F)
                    })

## bind each file's density estimate into a single dataframe
densities <- do.call("rbind", densities)

ungated_final$gated <- sapply(X = 1:nrow(ungated_final), 
                              FUN = function(x) {
                                  
                                  ## get file name for current row
                                  f_name <- ungated_final[x, "file_string"]

                                  ## get corresponding row of density estimates
                                  dens_row <- densities[densities$f_name == f_name, ]
                                  
                                  ## 10% +/- the max FSC density peak
                                  dens_up   <- dens_row$dens_up
                                  dens_down <- dens_row$dens_down
                                  
                                  ## create a gate and subset to keep cells in range
                                  ifelse(ungated_final[x, "FSC.A"] > dens_down &
                                         ungated_final[x, "FSC.A"] < dens_up,
                                         yes = T, no = F)

                     })


ungated_per_file <- tapply(X = ungated_final$FSC.A,
                           INDEX = ungated_final$file_name,
                           FUN = length)

gated_per_file <- tapply(X = ungated_final$FSC.A[ungated_final$gated == T],
                         INDEX = ungated_final$file_name[ungated_final$gated == T],
                         FUN = length)

fsc_gated_counts <- data.frame(kept = gated_per_file,
                               excluded = ungated_per_file - gated_per_file,
                               percent = gated_per_file / ungated_per_file)

gate_string <- paste0("\n3. On ", Sys.time(),
                      " Filtered cells to grab 10% +/- the central FSC peak\n\n",
                      "The following counts were obtained:\n")

write(x = gate_string,
      file = out_log,
      append = T)

cat(capture.output(fsc_gated_counts),
    file = out_log,
    append = T,
    sep = "\n")


## -----
## write out summary statistics for gated and ungated files
## extract only numeric parameters for summary statistics 
f_params <- colnames(ungated_final)
f_params <- f_params[sapply(X = f_params,
           FUN = function(x) {
               is.numeric(ungated_final[, x])
               })]

## -----
## write out summary statistics for all parameters 
## make sure all columns are printed together 
options(width = 200)
for(p in 1:length(f_params)) {

    gated_final    <- ungated_final[ungated_final$gated == T, ]

    ungated_mean   <- tapply(X = ungated_final[, f_params[p]],
                             INDEX = ungated_final$file_name,
                             FUN = mean)
    gated_mean     <- tapply(X = gated_final[, f_params[p]],
                             INDEX = gated_final$file_name,
                             FUN = mean)
    mean_frac      <- round(x = gated_mean / ungated_mean,
                            digits = 2)
    ungated_median <- tapply(X = ungated_final[, f_params[p]],
                             INDEX = ungated_final$file_name,
                             FUN = median)
    gated_median   <- tapply(X = gated_final[, f_params[p]],
                             INDEX = gated_final$file_name,
                             FUN = median)
    median_frac      <- round(x = gated_median / ungated_median,
                              digits = 2)
    ungated_sd     <- tapply(X = ungated_final[, f_params[p]],
                             INDEX = ungated_final$file_name,
                             FUN = sd)
    gated_sd       <- tapply(X = gated_final[, f_params[p]],
                             INDEX = gated_final$file_name,
                             FUN = sd)
        
    ungated_cv     <- ungated_mean / ungated_sd

    gated_cv       <- gated_mean / gated_sd

    sum_stats      <- data.frame(ungated_mean, gated_mean, mean_frac,
                                 ungated_median, gated_median, median_frac,
                                 ungated_sd, gated_sd,
                                 ungated_cv, gated_cv)

    sum_string     <- paste0("\nOn ", Sys.time(), " Obtained summary statistics for parameter: ",
                             f_params[p], "\n\n")

    write(x = sum_string,
      file = out_log,
      append = T)

    cat(capture.output(sum_stats),
        file = out_log,
        append = T,
        sep = "\n")
    
}


## -----
## extract strain, reporter, and replicate as factors

## now, extract the strain from the file name string
## this relies on naming the files w/ strain, reporter,
## and replicated separated by a '-' character, as in:
## "BY_full_gRNA_02-ODC_TFT-003.fcs" for the:
## strain - "BY full gRNA 02"
## reporter - ODC TFT
## replicate - 3

## because of 'strsplits' list output format, have to use
## 'sapply' to create the 'strain' variable.  Output is, e.g.,:
## [[1]]
## [1] "BY_full_gRNA_02" "ODC_TFT"         "003.fcs"
## so, take the 1st index of the appropriate list item
ungated_final$strain <- sapply(X = 1:length(ungated_final$file_string),
                               FUN = function(x){
                                   strsplit(x = ungated_final$file_string[x], split = "-")[[1]][1]
                               })
ungated_final$strain_factor <- as.factor(ungated_final$strain)

## now write the unique values we obtain for strain in ea. dataset
write(x = sprintf("%s", c("\nUnique values for 'strain' variable:\n",
                          unique(ungated_final$strain))),
      file = out_log,
      append = T)

## now for reporter
ungated_final$reporter <- sapply(X = 1:length(ungated_final$file_string),
                                 FUN = function(x){
                                     strsplit(x = ungated_final$file_string[x], split = "-")[[1]][2]
                                 })
ungated_final$reporter_factor <- as.factor(ungated_final$reporter)

## log the results
write(x = sprintf("%s", c("\nUnique values for 'reporter' variable for ungated set:\n",
                          unique(ungated_final$reporter))),
      file = out_log,
      append = T)


## now for replicates
ungated_final$replicate <- sapply(X = 1:length(ungated_final$file_string),
                                  FUN = function(x){
                                      as.numeric(
                                          gsub(pattern = ".fcs",
                                               replacement = "",
                                               x = strsplit(x = ungated_final$file_string[x],
                                                            split = "-")[[1]][3]))
                                  })
## for later use in plotting individual replicates
ungated_final$replicate_factor <- as.factor(ungated_final$replicate)


## log the results
write(x = sprintf("%s", c("\nUnique values for 'replicate' variable for ungated set:\n",
                          unique(ungated_final$replicate))),
      file = out_log,
      append = T)


## -----
## get plate information and create a variable that 
## expresses time relative to the first sample for ea. plate
ungated_final$plate <- ifelse(test = ungated_final$replicate <= 8,
                              yes  = "plate_01",
                              no   = "plate_02")

## ungated_final$plate <- as.numeric(sapply(X = sapply(X = ungated_final$file_string,
##                                                     FUN = function(x) {
##                                                         x = unlist(strsplit(x = x,
##                                                                             split = ".*-"))[2]}),
##                                          FUN = function(y) {
##                                              unlist(strsplit(x = y,
##                                                              split = ".fcs")[1])
##                                          }))

ungated_final$plate <- ifelse(test = ungated_final$replicate <= 8,
                              yes  = "plate_01",
                              no   = "plate_02")

plate_one_min <- min(ungated_final$time_conv[ungated_final$plate == "plate_01"])
plate_two_min <- min(ungated_final$time_conv[ungated_final$plate == "plate_02"])

## convert time to a relative value based on the first sample of ea. plate
ungated_final$time_rel <- sapply(X = 1:nrow(ungated_final),
                                 FUN = function(x) {
                                     ifelse(test = ungated_final[x, "plate"] == "plate_01",
                                            yes  = ungated_final[x, "time_conv"] - plate_one_min, 
                                            no   = ungated_final[x, "time_conv"] - plate_two_min)
                                 })

## log relative time values per file
time_string <- paste0("\nOn ", Sys.time(), "Extracted time values for each file/plate\n")

write(x = time_string,
      file = out_log,
      append = T) 

time_frame <- lapply(X = unique(ungated_final$file_string),
                     FUN = function(x) {

                         sub_set <- ungated_final$file_string == x
                         f_params <- c("file_string", "strain", "plate",
                                     "file_time", "time_conv", "time_rel")
                         dat <- ungated_final[sub_set, f_params]
                         dat_out <- data.frame(file = unique(dat$file_string),
                                               strain = unique(dat$strain),
                                               plate = unique(dat$plate),
                                               file_time = unique(dat$file_time),
                                               time_conv = unique(dat$time_conv),
                                               time_rel = unique(dat$time_rel))
                     })

time_frame <- do.call("rbind", time_frame)

cat(capture.output(time_frame),
    file = out_log,
    append = T,
    sep = "\n")


## -----
## save the final dataframe for future use:
save(ungated_final,
     file = paste0(frame_dir, "/ungated_final.R"))

write(x = paste0("\nOn ", Sys.time(), " saved final dataframe as: ",
                 paste0(frame_dir, "/", "ungated_final.R"),
                 "\n"),
                 file = out_log,
                 append = T)

save(work_dir, results_dir, tables_dir, sessions_dir,
     frame_dir, gated_dir, ungated_dir, out_log,
     file = paste0(frame_dir, "/dir_structure.R"))

write(x = paste0("\nOn ", Sys.time(), " saved dir structure as: ",
                 paste0(frame_dir, "/dir_structure.R"),
                 "\n"),
                 file = out_log,
                 append = T)

## -----
## re-load the data by uncommenting the following:
## load(file = paste0(frame_dir, "/", "ungated_final.R"))
## load(file = paste0(frame_dir, "/dir_structure.R"))
## source("~/emacs/R/functions/load_flow_packages.R")


## -----
## extract the median from each biological replicate and use this
## value to build a dataframe w/ n. replicate observations per strain
## per reporter.  This dataframe is what we'll use for stats and for
## creating stripcharts, boxplots, and heatmaps

## 'aggregate' creates a new dataframe from x by applying FUN to
## all unique combinations of the factors supplied to the 'by'
## argument - in this case, grab the mean of numeric data and
## keep everything else a factor
ungated_medians <- aggregate.data.frame(x = ungated_final,
                                        by = list(ungated_final$strain_factor,
                                                  ungated_final$replicate_factor,
                                                  ungated_final$reporter_factor),
                                        FUN = function(x) {
                                            ifelse(is.numeric(x), median(x), as.character(x))
                                        },
                                        ## simplify results to vector 
                                        simplify = T)


## -----
## 'aggregate' seems to strip the levels from factors, so add
## these back using the values present in the original dataframe
ungated_medians$strain_factor    <- as.factor(ungated_medians$strain)
ungated_medians$replicate_factor <- as.factor(ungated_medians$replicate)
ungated_medians$reporter_factor  <- as.factor(ungated_medians$reporter)
ungated_medians$gating           <- rep("ungated", nrow(ungated_medians))


## -----
## subtract the deletion strain value from each replicate
## the deletion strain TFT ratio will be ~0, but not exactly
## thus, we normalize to it before converting to z-scores 
## ungated_medians[which.min(ungated_medians$TFT_ratio), ]
TFT_min <- min(ungated_medians$TFT_ratio)
ungated_medians$TFT_sub <- ungated_medians$TFT_ratio - TFT_min
ungated_medians <- ungated_medians[ungated_medians$strain != "doa10_strain", ]
ungated_medians <- ungated_medians[ungated_medians$strain != "ubr1_strain", ]
ungated_medians <- ungated_medians[ungated_medians$strain != "nta1_strain", ]
ungated_medians <- ungated_medians[ungated_medians$strain != "rpn4_strain", ]
ungated_medians <- ungated_medians[ungated_medians$strain != "ubc6_strain", ]


## -----
## adjust for the effect of time on the TFT ratio,
## then convert it to a Z-score: 
ungated_loess <- loess(formula = TFT_sub ~ time_rel,
                       data = ungated_medians)
ungated_medians$TFT_loess <- ungated_loess$residuals + mean(ungated_medians$TFT_ratio)

## scale to wild-type median with sd = 1
by_median <- median(ungated_medians$TFT_loess[ungated_medians$strain == "BY_full"])
ungated_medians$TFT_scaled <- scale(x = ungated_medians$TFT_loess,
                                    center = by_median,
                                    scale = T)

## -----
## re-level prior to statistical analysis
ungated_medians$strain_ordered <- factor(ungated_medians$strain_factor,
                                         levels = levels(ungated_medians$strain_factor)[c(2, 1,
                                                                                          6, 5,
                                                                                          4, 7,
                                                                                          3)])

## drop the deletion strain level from the dataset
ungated_medians$strain_final <- droplevels(x = ungated_medians$strain_ordered)
## levels(ungated_medians$strain_final)

## -----
## have to extract medians from the gated data separately
gated_final <- ungated_final[ungated_final$gated == T, ]

gated_medians <- aggregate.data.frame(x = gated_final,
                                       by = list(gated_final$strain_factor,
                                                 gated_final$replicate_factor,
                                                 gated_final$reporter_factor),
                                       FUN = function(x) {
                                           ifelse(is.numeric(x), median(x), as.character(x))
                                       },
                                       ## simplify results to vector 
                                       simplify = T)

## 'aggregate' seems to strip the levels from factors, so add
## these back using the values present in the original dataframe
gated_medians$strain_factor    <- as.factor(gated_medians$strain)
gated_medians$replicate_factor <- as.factor(gated_medians$replicate)
gated_medians$reporter_factor  <- as.factor(gated_medians$reporter)
gated_medians$gating           <- rep("gated", nrow(gated_medians))

## -----
## subtract the deletion strain value from each replicate
## the deletion strain TFT ratio will be ~0, but not exactly
## thus, we normalize to it before converting to z-scores 
## gated_medians[which.min(gated_medians$TFT_ratio), ]
TFT_min <- min(gated_medians$TFT_ratio)
gated_medians$TFT_sub <- gated_medians$TFT_ratio - TFT_min
gated_medians <- gated_medians[gated_medians$strain != "doa10_strain", ]
gated_medians <- gated_medians[gated_medians$strain != "ubr1_strain", ]
gated_medians <- gated_medians[gated_medians$strain != "nta1_strain", ]
gated_medians <- gated_medians[gated_medians$strain != "rpn4_strain", ]
gated_medians <- gated_medians[gated_medians$strain != "ubc6_strain", ]


## -----
## adjust for the effect of time on the TFT ratio,
## then convert it to a Z-score: 
gated_loess <- loess(formula = TFT_sub ~ time_rel,
                     data = gated_medians)
gated_medians$TFT_loess <- gated_loess$residuals + mean(gated_medians$TFT_ratio)

## scale to wild-type median with sd = 1
by_median <- median(gated_medians$TFT_loess[gated_medians$strain == "BY_full"])
gated_medians$TFT_scaled <- scale(x = gated_medians$TFT_loess,
                                  center = by_median,
                                  scale = T)

## -----
## re-level prior to statistical analysis
gated_medians$strain_ordered <- factor(gated_medians$strain_factor,
                                       levels = levels(gated_medians$strain_factor)[c(2, 1,
                                                                                      6, 5,
                                                                                      4, 7,
                                                                                      3)])

gated_medians$strain_final <- droplevels(x = gated_medians$strain_ordered)
## levels(gated_medians$strain_final)


## -----
## re-load point 
## dump the gated and ungated cells into a single list
all_data <- list()
all_data[[1]] <- ungated_medians
all_data[[2]] <- gated_medians
names(all_data) <- c("ungated_medians", "gated_medians")
save(all_data,
     file = paste0(frame_dir, "/all_data.R"))


## -----
## ## re-load point 
## load(file = paste0(frame_dir, "/dir_structure.R"))
## load(file = paste0(frame_dir, "/all_data.R"))


## -----
## 'lapply' to get the statistics
f_params <- c("TFT_ratio", "TFT_loess", "TFT_scaled")

lapply(X = all_data,
       FUN = function(n) {
           
           sapply(X = f_params,
                  FUN = function(p) {

                      ## -----
                      ## write ungated aov output to file
                      write(x = paste0("-------------------------------------\n",
                                       "|", unique(n$gating),
                                       " cells: ANOVA for parameter:|\n",
                                       "-------------------------------------\n",
                                       p, " on", " ", Sys.time(), "\n"),
                            file = stats_log,
                            append = T)
                      
                      test_aov <- aov(n[, p] ~ ungated_medians[, "strain_final"])
                      
                      capture.output(summary(test_aov),
                                     file = stats_log,
                                     append = T,
                                     type = "output",
                                     split = F)
                      
                      write(x = "\n",
                            file = stats_log,
                            append = T)

                      ## -----
                      ## now the Tukey HSD posthoc test for the ungated set
                      test_posthoc <- TukeyHSD(test_aov)
                      test_posthoc_out <- as.data.frame(test_posthoc[[1]])
                      test_posthoc_out$reporter <- rep(unique(n$reporter),
                                                       nrow(test_posthoc_out))
                      
                      write(x = paste0("---------------------------------------\n",
                                       "|", unique(n$gating),
                                       " cells: Tukey HSD for parameter:|\n",
                                       "---------------------------------------\n",
                                       p, " on", " ", Sys.time(), "\n"),
                            file = stats_log,
                            append = T)
                      
                      capture.output(x = test_posthoc_out,
                                     file = stats_log,
                                     append = T,
                                     type = "output",
                                     split = F)
                      
                      write(x = "\n",
                            file = stats_log,
                            append = T)

                      ## -----
                      ## pairwise t-test posthoc (for comparison to Tukey) for the ungated set
                      write(x = paste0("----------------------------------------\n",
                                       "|", unique(n$gating),
                                       " cells: Pairwise t for parameter:|\n",
                                       "----------------------------------------\n",
                                       p, " on", " ", Sys.time(), "\n"),
                            file = stats_log,
                            append = T)
                      
                      capture.output(
                          pairwise.t.test(x = n[, p],
                                          g = n[, "strain_final"],
                                          p.adjust.method = "BH",
                                          alternative = "two.sided")$p.value,
                          file = stats_log,
                          append = T,
                          type = "output",
                          split = F)

                                            ## -----
                      ## pairwise t-test posthoc (for comparison to Tukey) for the ungated set
                      write(x = paste0("-------------------------------------------------\n",
                                       "|", unique(n$gating),
                                       " cells: Pairwise t w/ no pooled SD for parameter:|\n",
                                       "-------------------------------------------------\n",
                                       p, " on", " ", Sys.time(), "\n"),
                            file = stats_log,
                            append = T)
                      
                      capture.output(
                          pairwise.t.test(x = n[, p],
                                          g = n[, "strain_final"],
                                          p.adjust.method = "BH",
                                          pool.sd = F,
                                          alternative = "two.sided")$p.value,
                          file = stats_log,
                          append = T,
                          type = "output",
                          split = F)
                      
                      write(x = "\n",
                            file = stats_log,
                            append = T)

                  }
                , simplify = F)
})
#+END_SRC

* 'N-end_stats_runner.R'                                           :R:HELPER:

#+BEGIN_SRC R :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/N-end_stats_runner.R
## -----
## ## re-load point 
load(file = paste0(frame_dir, "/dir_structure.R"))
load(file = paste0(frame_dir, "/all_data.R"))

ungated_medians <- all_data[[1]]
gated_medians   <- all_data[[2]]

## -----
## 'lapply' to get the statistics
f_params <- c("TFT_ratio", "TFT_loess", "TFT_scaled")

lapply(X = all_data,
       FUN = function(n) {
           
           sapply(X = f_params,
                  FUN = function(p) {

                      ## -----
                      ## write ungated aov output to file
                      write(x = paste0("-------------------------------------\n",
                                       "|", unique(n$gating),
                                       " cells: ANOVA for parameter:|\n",
                                       "-------------------------------------\n",
                                       p, " on", " ", Sys.time(), "\n"),
                            file = stats_log,
                            append = T)
                      
                      test_aov <- aov(n[, p] ~ ungated_medians[, "strain_final"])
                      
                      capture.output(summary(test_aov),
                                     file = stats_log,
                                     append = T,
                                     type = "output",
                                     split = F)
                      
                      write(x = "\n",
                            file = stats_log,
                            append = T)

                      ## -----
                      ## now the Tukey HSD posthoc test for the ungated set
                      test_posthoc <- TukeyHSD(test_aov)
                      test_posthoc_out <- as.data.frame(test_posthoc[[1]])
                      test_posthoc_out$reporter <- rep(unique(n$reporter),
                                                       nrow(test_posthoc_out))
                      
                      write(x = paste0("---------------------------------------\n",
                                       "|", unique(n$gating),
                                       " cells: Tukey HSD for parameter:|\n",
                                       "---------------------------------------\n",
                                       p, " on", " ", Sys.time(), "\n"),
                            file = stats_log,
                            append = T)
                      
                      capture.output(x = test_posthoc_out,
                                     file = stats_log,
                                     append = T,
                                     type = "output",
                                     split = F)
                      
                      write(x = "\n",
                            file = stats_log,
                            append = T)

                      ## -----
                      ## pairwise t-test posthoc (for comparison to Tukey) for the ungated set
                      write(x = paste0("----------------------------------------\n",
                                       "|", unique(n$gating),
                                       " cells: Pairwise t for parameter:|\n",
                                       "----------------------------------------\n",
                                       p, " on", " ", Sys.time(), "\n"),
                            file = stats_log,
                            append = T)
                      
                      capture.output(
                          pairwise.t.test(x = n[, p],
                                          g = n[, "strain_final"],
                                          p.adjust.method = "BH",
                                          alternative = "two.sided")$p.value,
                          file = stats_log,
                          append = T,
                          type = "output",
                          split = F)

                                            ## -----
                      ## pairwise t-test posthoc (for comparison to Tukey) for the ungated set
                      write(x = paste0("-------------------------------------------------\n",
                                       "|", unique(n$gating),
                                       " cells: Pairwise t w/ no pooled SD for parameter:|\n",
                                       "-------------------------------------------------\n",
                                       p, " on", " ", Sys.time(), "\n"),
                            file = stats_log,
                            append = T)
                      
                      capture.output(
                          pairwise.t.test(x = n[, p],
                                          g = n[, "strain_final"],
                                          p.adjust.method = "BH",
                                          pool.sd = F,
                                          alternative = "two.sided")$p.value,
                          file = stats_log,
                          append = T,
                          type = "output",
                          split = F)
                      
                      write(x = "\n",
                            file = stats_log,
                            append = T)

                  }
                , simplify = F)
})


#+END_SRC

* DOA10 Thr Fine-Mapping Flow                                             :R:

#+BEGIN_SRC R
## -----
## START USER INPUT
## no trailing '/' at the end!
base_dir  <- "~/data/flow/2022.04.06_DOA10_Thr_1043_CRISPR_swap_flow"
frame_dir <- paste0(base_dir, "/dataframes")
stats_log <- paste0(base_dir, "/results/stats_log")
## END USER INPUT 


## -----
## run the analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/auto_process_N-end_fcs_files.R")

## statistical analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/N-end_stats_runner.R")


## -----
## load the extracted median for ea. parameter and bio. replicate: 
load(file = paste0(frame_dir, "/all_data.R"))

all_data[[2]] <- all_data[[2]][all_data[[2]]$strain != "BY_strain", ]
str(all_data[[2]])

all_data[[2]]$strain_final <- droplevels(all_data[[2]]$strain_final)
all_data[[2]]$strain_final <- factor(all_data[[2]]$strain_final,
                                     levels = levels(all_data[[2]]$strain_final))
levels(all_data[[2]]$strain_final)

## -----
## make plots
cols <- ifelse(test = grepl(pattern = ".*BY.*",
                            x = levels(all_data[[2]]$strain_final)),
               yes = "#2166AC77",
               no = "#BF323277")

dat_range <- range(all_data[[2]]$TFT_scaled)
down_range <- dat_range[1] - abs(0.1 * dat_range[1])
up_range <- dat_range[2] + abs(0.15 * dat_range[2])
plot_ranges <- c(down_range, up_range)


## -----
## boxplot w/ pvals 
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_DOA10_Thr_TFT.pdf")
print(
xyplot(all_data[[2]]$TFT_scaled ~ all_data[[2]]$strain_final,
       groups = all_data[[2]]$strain_final,
       ylim = plot_ranges,
       ylab = "UPS Activity Relative to\n BY Allele Median (SD units)",
       xlab = "",
       scales = list(tck = c(1, 0),
                     alternating = F,
                     x = list(labels = c(expression(italic("DOA10")*" BY"),
                                         expression(italic("DOA10")*" RM"),
                                         expression(italic("DOA10")*" Q410E"),
                                         expression(italic("DOA10")*" K1012N"),
                                         expression(italic("DOA10")*" Y1186F")),
                              rot = 45,
                              cex = 1.25),
                     y = list(at = seq(from = -3, to = 3, by = 0.5),
                              cex = 1.25)),
       par.settings = list(box.dot = list(pch = "|"),
                           box.umbrella = list(lty = 1,
                                               lwd = 1,
                                               col = gray(0.4)),
                           box.rectangle = list(lty = 1,
                                                lwd = 1,
                                                col = gray(0.4),
                                                fill = gray(0.97)),
                           strip.background = list(col = gray(0.9)),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25),
                           clip = list(panel = F),
                           layout.heights = list(top.padding = 2)),
       panel = function(...) {
           panel.abline(h = 0, col = gray(0.5), lty = 2)
           panel.bwplot(...,
                        horizontal = F,
                        do.out = F)
           panel.segments(x0 = 1:5 - 0.25,
                          x1 = 1:5 + 0.25,
                          y0 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          y1 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          lwd = 1.5)
           panel.stripplot(...,
                           pch = 21,
                           cex = 1,
                           fill = cols,
                           col = "black",
                           jitter.data = T,
                           amount = 0.1,
                           horizontal = F)
           ## TFT label at top of plot 
           panel.text(x = 3,
                      y = dat_range[2] + 0.5,
                      fontface = "bold",
                      cex = 1.25,
                      labels = gsub(pattern = "_",
                                    replacement = " ",
                                    x = unique(all_data[[2]]$reporter)))
           ## pvals
           panel.text(x = 1,
                      y = dat_range[2] + 0.2,
                      labels = expression(italic("p")),
                      cex = 1.25)
           panel.text(x = 2:5,
                      y = rep(dat_range[2] + 0.2, 4),
                      fontface = "plain",
                      cex = 1.25,
                      labels = c("2.6e-16",
                                 "0.088",
                                 "0.16",
                                 "3.6e-07"))
       })
       )
## code end
dev.off()


## -----
## put the variant effects in a simple data frame
allele_effects <- data.frame(allele = levels(all_data[[2]]$strain_final))
allele_effects$gene <- rep("DOA10", nrow(allele_effects))
allele_effects$reporter <- rep(unique(all_data[[2]]$reporter),
                               times = nrow(allele_effects))
allele_effects$effect <-  tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                                 FUN = median)
allele_effects$sem <- tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                             FUN = function(x) {
                                 sd(x) / sqrt(length(x))
})
allele_effects$pvals <- c(1,
                          2.572290e-16,
                          8.842868e-02,
                          1.632779e-01,
                          3.640046e-07)

allele_effects

save(allele_effects,
     file = paste0(frame_dir, "/fine-mapping_DOA10_Thr_effects.R"))
#+END_SRC

* DOA10 Gly Fine-Mapping Flow                                             :R:

#+BEGIN_SRC R
## -----
## START USER INPUT
## no trailing '/' at the end!
base_dir  <- "~/data/flow/2021.07.20_DOA10_Gly_1047_CRISPR_swap_flow"
frame_dir <- paste0(base_dir, "/dataframes")
stats_log <- paste0(base_dir, "/results/stats_log")
## END USER INPUT 


## -----
## run the analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/auto_process_N-end_fcs_files.R")

## statistical analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/N-end_stats_runner.R")


## -----
## load the extracted median for ea. parameter and bio. replicate: 
load(file = paste0(frame_dir, "/all_data.R"))

all_data[[2]] <- all_data[[2]][all_data[[2]]$strain != "BY_strain", ]
str(all_data[[2]])

all_data[[2]]$strain_final <- droplevels(all_data[[2]]$strain_final)
all_data[[2]]$strain_final <- factor(all_data[[2]]$strain_final,
                                     levels = levels(all_data[[2]]$strain_final))
levels(all_data[[2]]$strain_final)

## -----
## make plots
cols <- ifelse(test = grepl(pattern = ".*BY.*",
                            x = levels(all_data[[2]]$strain_final)),
               yes = "#2166AC77",
               no = "#BF323277")

dat_range <- range(all_data[[2]]$TFT_scaled)
down_range <- dat_range[1] - abs(0.1 * dat_range[1])
up_range <- dat_range[2] + abs(0.15 * dat_range[2])
plot_ranges <- c(down_range, up_range)


## -----
## boxplot w/ pvals 
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_DOA10_Gly_TFT.pdf")
print(
xyplot(all_data[[2]]$TFT_scaled ~ all_data[[2]]$strain_final,
       groups = all_data[[2]]$strain_final,
       ylim = plot_ranges,
       ylab = "UPS Activity Relative to\n BY Allele Median (SD units)",
       xlab = "",
       scales = list(tck = c(1, 0),
                     alternating = F,
                     x = list(labels = c(expression(italic("DOA10")*" BY"),
                                         expression(italic("DOA10")*" RM"),
                                         expression(italic("DOA10")*" Q410E"),
                                         expression(italic("DOA10")*" D111E"),
                                         expression(italic("DOA10")*" E129G")),
                              rot = 45,
                              cex = 1.25),
                     y = list(at = seq(from = -3, to = 3, by = 0.5),
                              cex = 1.25)),
       par.settings = list(box.dot = list(pch = "|"),
                           box.umbrella = list(lty = 1,
                                               lwd = 1,
                                               col = gray(0.4)),
                           box.rectangle = list(lty = 1,
                                                lwd = 1,
                                                col = gray(0.4),
                                                fill = gray(0.97)),
                           strip.background = list(col = gray(0.9)),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25),
                           clip = list(panel = F),
                           layout.heights = list(top.padding = 2)),
       panel = function(...) {
           panel.abline(h = 0, col = gray(0.5), lty = 2)
           panel.bwplot(...,
                        horizontal = F,
                        do.out = F)
           panel.segments(x0 = 1:5 - 0.25,
                          x1 = 1:5 + 0.25,
                          y0 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          y1 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          lwd = 1.5)
           panel.stripplot(...,
                           pch = 21,
                           cex = 1,
                           fill = cols,
                           col = "black",
                           jitter.data = T,
                           amount = 0.1,
                           horizontal = F)
           ## TFT label at top of plot 
           panel.text(x = 3,
                      y = dat_range[2] + 0.4,
                      fontface = "bold",
                      cex = 1.25,
                      labels = gsub(pattern = "_",
                                    replacement = " ",
                                    x = unique(all_data[[2]]$reporter)))
           ## pvals
           panel.text(x = 1,
                      y = dat_range[2] + 0.2,
                      labels = expression(italic("p")),
                      cex = 1.25)
           panel.text(x = 2:5,
                      y = rep(dat_range[2] + 0.2, 4),
                      fontface = "plain",
                      cex = 1.25,
                      labels = c("8.7e-13",
                                 "4.8e-10",
                                 "1.8e-07",
                                 "3.3e-10"))
       })
)
## code end
dev.off()


## -----
## put the variant effects in a simple data frame
allele_effects <- data.frame(allele = levels(all_data[[2]]$strain_final))
allele_effects$gene <- rep("DOA10", nrow(allele_effects))
allele_effects$reporter <- rep(unique(all_data[[2]]$reporter),
                               times = nrow(allele_effects))
allele_effects$effect <-  tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                                 FUN = median)
allele_effects$sem <- tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                             FUN = function(x) {
                                 sd(x) / sqrt(length(x))
                             })
allele_effects$pvals <- c(1,
                          8.716145e-13,
                          4.784803e-10,
                          1.822012e-07,
                          3.299164e-10)

allele_effects

save(allele_effects,
     file = paste0(frame_dir, "/fine-mapping_DOA10_Gly_effects.R"))

#+END_SRC

* NTA1 Asn Fine-Mapping Flow                                              :R:

#+BEGIN_SRC R
## -----
## START USER INPUT
## no trailing '/' at the end!
base_dir  <- "~/data/flow/2021.07.08_NTA1_Asn_0657_CRISPR_swap_flow"
frame_dir <- paste0(base_dir, "/dataframes")
stats_log <- paste0(base_dir, "/results/stats_log")
## END USER INPUT 


## -----
## run the analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/auto_process_N-end_fcs_files.R")

## statistical analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/N-end_stats_runner.R")


## -----
## load the extracted median for ea. parameter and bio. replicate: 
load(file = paste0(frame_dir, "/all_data.R"))

all_data[[2]] <- all_data[[2]][all_data[[2]]$strain != "BY_strain", ]
str(all_data[[2]])

all_data[[2]]$strain_final <- droplevels(all_data[[2]]$strain_final)
all_data[[2]]$strain_final <- factor(all_data[[2]]$strain_final,
                                     levels = levels(all_data[[2]]$strain_final)[c(1, 2, 4, 5, 3)])
levels(all_data[[2]]$strain_final)

## -----
## make plots
cols <- ifelse(test = grepl(pattern = ".*BY.*",
                            x = levels(all_data[[2]]$strain_final)),
               yes = "#2166AC77",
               no = "#BF323277")

dat_range <- range(all_data[[2]]$TFT_scaled)
down_range <- dat_range[1] - abs(0.1 * dat_range[1])
up_range <- dat_range[2] + abs(0.15 * dat_range[2])
plot_ranges <- c(down_range, up_range)


## -----
## boxplot w/ pvals 
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_NTA1_Asn_TFT.pdf")
print(
xyplot(all_data[[2]]$TFT_scaled ~ all_data[[2]]$strain_final,
       groups = all_data[[2]]$strain_final,
       ylim = plot_ranges,
       ylab = "UPS Activity Relative to\n BY Allele Median (SD units)",
       xlab = "",
       scales = list(tck = c(1, 0),
                     alternating = F,
                     x = list(labels = c(expression(italic("NTA1")*" BY"),
                                         expression(italic("NTA1")*" RM"),
                                         expression(italic("NTA1")*" RM pr"),
                                         expression(italic("NTA1")*" D111E"),
                                         expression(italic("NTA1")*" E129G")),
                              rot = 45,
                              cex = 1.25),
                     y = list(at = seq(from = -2, to = 2.5, by = 0.5),
                              cex = 1.25)),
       par.settings = list(box.dot = list(pch = "|"),
                           box.umbrella = list(lty = 1,
                                               lwd = 1,
                                               col = gray(0.4)),
                           box.rectangle = list(lty = 1,
                                                lwd = 1,
                                                col = gray(0.4),
                                                fill = gray(0.97)),
                           strip.background = list(col = gray(0.9)),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25),
                           clip = list(panel = F),
                           layout.heights = list(top.padding = 2)),
       panel = function(...) {
           panel.abline(h = 0, col = gray(0.5), lty = 2)
           panel.bwplot(...,
                        horizontal = F,
                        do.out = F)
           panel.segments(x0 = 1:5 - 0.25,
                          x1 = 1:5 + 0.25,
                          y0 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          y1 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          lwd = 1.5)
           panel.stripplot(...,
                           pch = 21,
                           cex = 1,
                           fill = cols,
                           col = "black",
                           jitter.data = T,
                           amount = 0.1,
                           horizontal = F)
           ## TFT label at top of plot 
           panel.text(x = 3,
                      y = dat_range[2] + 0.5,
                      fontface = "bold",
                      cex = 1.25,
                      labels = gsub(pattern = "_",
                                    replacement = " ",
                                    x = unique(all_data[[2]]$reporter)))
           ## pvals
           panel.text(x = 1,
                      y = dat_range[2] + 0.2,
                      labels = expression(italic("p")),
                      cex = 1.25)
           panel.text(x = 2:5,
                      y = rep(dat_range[2] + 0.2, 5),
                      fontface = "plain",
                      cex = 1.25,
                      labels = c("3.8e-11",
                                 "0.53",
                                 "7.6e-03",
                                 "2.1e-10"))
       })
)
## code end
dev.off()


## -----
## put the variant effects in a simple data frame
allele_effects <- data.frame(allele = levels(all_data[[2]]$strain_final))
allele_effects$gene <- rep("NTA1", nrow(allele_effects))
allele_effects$reporter <- rep(unique(all_data[[2]]$reporter),
                               times = nrow(allele_effects))
allele_effects$effect <-  tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                                 FUN = median)
allele_effects$sem <- tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                             FUN = function(x) {
                                 sd(x) / sqrt(length(x))
})
allele_effects$pvals <- c(1,
                          3.751343e-11,
                          5.219761e-01,
                          7.579118e-03,
                          2.149118e-10)

allele_effects

save(allele_effects,
     file = paste0(frame_dir, "/fine-mapping_NTA1_Asn_effects.R"))
#+END_SRC

* UBC6 Ala Fine-Mapping Flow                                              :R:

#+BEGIN_SRC R
## -----
## START USER INPUT
## no trailing '/' at the end!
base_dir  <- "~/data/flow/2021.07.16_UBC6_Ala_1049_CRISPR_swap_flow"
frame_dir <- paste0(base_dir, "/dataframes")
stats_log <- paste0(base_dir, "/results/stats_log")
## END USER INPUT 


## -----
## run the analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/auto_process_N-end_fcs_files.R")

## statistical analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/N-end_stats_runner.R")


## -----
## load the extracted median for ea. parameter and bio. replicate: 
load(file = paste0(frame_dir, "/all_data.R"))

all_data[[2]] <- all_data[[2]][all_data[[2]]$strain != "BY_strain", ]
str(all_data[[2]])

all_data[[2]]$strain_final <- droplevels(all_data[[2]]$strain_final)
all_data[[2]]$strain_final <- factor(all_data[[2]]$strain_final,
                                     levels = levels(all_data[[2]]$strain_final)[c(1, 3, 2, 5, 4)])
levels(all_data[[2]]$strain_final)

## -----
## make plots
cols <- ifelse(test = grepl(pattern = ".*BY.*",
                            x = levels(all_data[[2]]$strain_final)),
               yes = "#2166AC77",
               no = "#BF323277")

dat_range <- range(all_data[[2]]$TFT_scaled)
down_range <- dat_range[1] - abs(0.35 * dat_range[1])
up_range <- dat_range[2] + abs(0.15 * dat_range[2])
plot_ranges <- c(down_range, up_range)


## -----
## boxplot w/ pvals 
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_UBC6_Ala_TFT.pdf")
print(
xyplot(all_data[[2]]$TFT_scaled ~ all_data[[2]]$strain_final,
       groups = all_data[[2]]$strain_final,
       ylim = plot_ranges,
       ylab = "UPS Activity Relative to\n BY Allele Median (SD units)",
       xlab = "",
       scales = list(tck = c(1, 0),
                     alternating = F,
                     x = list(labels = c(expression(italic("UBC6")*" BY"),
                                         expression(italic("UBC6")*" RM"),
                                         expression(italic("UBC6")*" RM pr"),
                                         expression(italic("UBC6")*" D229G"),
                                         expression(italic("UBC6")*" RM term")),
                              rot = 45,
                              cex = 1.25),
                     y = list(at = seq(from = -3, to = 3, by = 0.5),
                              cex = 1.25)),
       par.settings = list(box.dot = list(pch = "|"),
                           box.umbrella = list(lty = 1,
                                               lwd = 1,
                                               col = gray(0.4)),
                           box.rectangle = list(lty = 1,
                                                lwd = 1,
                                                col = gray(0.4),
                                                fill = gray(0.97)),
                           strip.background = list(col = gray(0.9)),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25),
                           clip = list(panel = F),
                           layout.heights = list(top.padding = 2)),
       panel = function(...) {
           panel.abline(h = 0, col = gray(0.5), lty = 2)
           panel.bwplot(...,
                        horizontal = F,
                        do.out = F)
           panel.segments(x0 = 1:5 - 0.25,
                          x1 = 1:5 + 0.25,
                          y0 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          y1 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          lwd = 1.5)
           panel.stripplot(...,
                           pch = 21,
                           cex = 1,
                           fill = cols,
                           col = "black",
                           jitter.data = T,
                           amount = 0.1,
                           horizontal = F)
           ## TFT label at top of plot 
           panel.text(x = 3,
                      y = dat_range[2] + 0.25,
                      fontface = "bold",
                      cex = 1.25,
                      labels = gsub(pattern = "_",
                                    replacement = " ",
                                    x = unique(all_data[[2]]$reporter)))
           ## pvals
           panel.text(x = 1,
                      y = dat_range[2] + 0.1,
                      labels = expression(italic("p")),
                      cex = 1.25)
           panel.text(x = 2:5,
                      y = rep(dat_range[2] + 0.1, 4),
                      fontface = "plain",
                      cex = 1.25,
                      labels = c("3.4e-08",
                                 "0.67",
                                 "1.6e-09",
                                 "0.016"))
       })
)
## code end
dev.off()



## -----
## put the variant effects in a simple data frame
allele_effects <- data.frame(allele = levels(all_data[[2]]$strain_final))
allele_effects$gene <- rep("UBC6", nrow(allele_effects))
allele_effects$reporter <- rep(unique(all_data[[2]]$reporter),
                               times = nrow(allele_effects))
allele_effects$effect <-  tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                                 FUN = median)
allele_effects$sem <- tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                             FUN = function(x) {
                                 sd(x) / sqrt(length(x))
})
allele_effects$pvals <- c(1,
                          3.429579e-08,
                          6.694758e-01,
                          1.619091e-09,
                          1.091131e-02)

allele_effects

save(allele_effects,
     file = paste0(frame_dir, "/fine-mapping_UBC6_Ala_effects.R"))
#+END_SRC

* UBC6 Thr Fine-Mapping Flow                                              :R:

#+BEGIN_SRC R
## -----
## START USER INPUT
## no trailing '/' at the end!
base_dir  <- "~/data/flow/2021.07.15_UBC6_Thr_1043_CRISPR_swap_flow"
frame_dir <- paste0(base_dir, "/dataframes")
stats_log <- paste0(base_dir, "/results/stats_log")
## END USER INPUT 


## -----
## run the analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/auto_process_N-end_fcs_files.R")

## statistical analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/N-end_stats_runner.R")


## -----
## load the extracted median for ea. parameter and bio. replicate: 
load(file = paste0(frame_dir, "/all_data.R"))

all_data[[2]] <- all_data[[2]][all_data[[2]]$strain != "BY_strain", ]
str(all_data[[2]])
 
all_data[[2]]$strain_final <- droplevels(all_data[[2]]$strain_final)
all_data[[2]]$strain_final <- factor(all_data[[2]]$strain_final,
                                     levels = levels(all_data[[2]]$strain_final)[c(1, 3, 2, 5, 4)])
levels(all_data[[2]]$strain_final)

## -----
## make plots
cols <- ifelse(test = grepl(pattern = ".*BY.*",
                            x = levels(all_data[[2]]$strain_final)),
               yes = "#2166AC77",
               no = "#BF323277")

dat_range <- range(all_data[[2]]$TFT_scaled)
down_range <- dat_range[1] - abs(0.35 * dat_range[1])
up_range <- dat_range[2] + abs(0.15 * dat_range[2])
plot_ranges <- c(down_range, up_range)


## -----
## boxplot w/ pvals 
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_UBC6_Thr_TFT.pdf")
print(
xyplot(all_data[[2]]$TFT_scaled ~ all_data[[2]]$strain_final,
       groups = all_data[[2]]$strain_final,
       ylim = plot_ranges,
       ylab = "UPS Activity Relative to\n BY Allele Median (SD units)",
       xlab = "",
       scales = list(tck = c(1, 0),
                     alternating = F,
                     x = list(labels = c(expression(italic("UBC6")*" BY"),
                                         expression(italic("UBC6")*" RM"),
                                         expression(italic("UBC6")*" RM pr"),
                                         expression(italic("UBC6")*" D229G"),
                                         expression(italic("UBC6")*" RM term")),
                              rot = 45,
                              cex = 1.25),
                     y = list(at = seq(from = -3, to = 3, by = 0.5),
                              cex = 1.25)),
       par.settings = list(box.dot = list(pch = "|"),
                           box.umbrella = list(lty = 1,
                                               lwd = 1,
                                               col = gray(0.4)),
                           box.rectangle = list(lty = 1,
                                                lwd = 1,
                                                col = gray(0.4),
                                                fill = gray(0.97)),
                           strip.background = list(col = gray(0.9)),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25),
                           clip = list(panel = F),
                           layout.heights = list(top.padding = 2)),
       panel = function(...) {
           panel.abline(h = 0, col = gray(0.5), lty = 2)
           panel.bwplot(...,
                        horizontal = F,
                        do.out = F)
           panel.segments(x0 = 1:5 - 0.25,
                          x1 = 1:5 + 0.25,
                          y0 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          y1 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          lwd = 1.5)
           panel.stripplot(...,
                           pch = 21,
                           cex = 1,
                           fill = cols,
                           col = "black",
                           jitter.data = T,
                           amount = 0.1,
                           horizontal = F)
           ## TFT label at top of plot 
           panel.text(x = 3,
                      y = dat_range[2] + 0.27,
                      fontface = "bold",
                      cex = 1.25,
                      labels = gsub(pattern = "_",
                                    replacement = " ",
                                    x = unique(all_data[[2]]$reporter)))
           ## pvals
           panel.text(x = 1,
                      y = dat_range[2] + 0.12,
                      labels = expression(italic("p")),
                      cex = 1.25)
           panel.text(x = 2:5,
                      y = rep(dat_range[2] + 0.13, 4),
                      fontface = "plain",
                      cex = 1.25,
                      labels = c("3.0e-18",
                                 "0.32",
                                 "6.1e-09",
                                 "0.33"))
       })
)
## code end
dev.off()


## -----
## put the variant effects in a simple data frame
allele_effects <- data.frame(allele = levels(all_data[[2]]$strain_final))
allele_effects$gene <- rep("UBC6", nrow(allele_effects))
allele_effects$reporter <- rep(unique(all_data[[2]]$reporter),
                               times = nrow(allele_effects))
allele_effects$effect <-  tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                                 FUN = median)
allele_effects$sem <- tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                             FUN = function(x) {
                                 sd(x) / sqrt(length(x))
})
allele_effects$pvals <- c(1,
                          3.045377e-18,
                          3.284160e-01,
                          6.126207e-09,
                          3.284160e-01)

allele_effects

save(allele_effects,
     file = paste0(frame_dir, "/fine-mapping_UBC6_Thr_effects.R"))

#+END_SRC

* UBR1 Asn Full Gene Fine-Mapping Flow                                    :R:

#+BEGIN_SRC R
## -----
## START USER INPUT
## no trailing '/' at the end!
base_dir  <- "~/data/flow/2021.02.12_UBR1_CRISPR_swap_0657_TFT_flow"
frame_dir <- paste0(base_dir, "/dataframes")
stats_log <- paste0(base_dir, "/results/stats_log")
## END USER INPUT 


## -----
## run the analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/auto_process_N-end_fcs_files.R")

## statistical analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/N-end_stats_runner.R")


## -----
## load the extracted median for ea. parameter and bio. replicate: 
load(file = paste0(frame_dir, "/all_data.R"))

all_data[[2]] <- all_data[[2]][all_data[[2]]$strain != "BY_strain", ]
str(all_data[[2]])
 
all_data[[2]]$strain_final <- droplevels(all_data[[2]]$strain_final)
all_data[[2]]$strain_final <- factor(all_data[[2]]$strain_final,
                                     levels = levels(all_data[[2]]$strain_final)[c(1, 5, 3, 4, 2)])
levels(all_data[[2]]$strain_final)

## -----
## make plots
cols <- ifelse(test = grepl(pattern = ".*BY.*",
                            x = levels(all_data[[2]]$strain_final)),
               yes = "#2166AC77",
               no = "#BF323277")

dat_range <- range(all_data[[2]]$TFT_scaled)
down_range <- dat_range[1] - abs(0.3 * dat_range[1])
up_range <- dat_range[2] + abs(0.4 * dat_range[2])
plot_ranges <- c(down_range, up_range)


## -----
## boxplot w/ pvals 
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_UBR1_Asn_fg_TFT.pdf")
print(
xyplot(all_data[[2]]$TFT_scaled ~ all_data[[2]]$strain_final,
       groups = all_data[[2]]$strain_final,
       ylim = plot_ranges,
       ylab = "UPS Activity Relative to\n BY Allele Median (SD units)",
       xlab = "",
       scales = list(tck = c(1, 0),
                     alternating = F,
                     x = list(labels = c(expression(italic("UBR1")*" BY"),
                                         expression(italic("UBR1")*" RM"),
                                         expression(italic("UBR1")*" RM pr"),
                                         expression(italic("UBR1")*" RM ORF"),
                                         expression(italic("UBR1")*" RM term")),
                              rot = 45,
                              cex = 1.25),
                     y = list(at = seq(from = -3, to = 3, by = 0.5),
                              cex = 1.25)),
       par.settings = list(box.dot = list(pch = "|"),
                           box.umbrella = list(lty = 1,
                                               lwd = 1,
                                               col = gray(0.4)),
                           box.rectangle = list(lty = 1,
                                                lwd = 1,
                                                col = gray(0.4),
                                                fill = gray(0.97)),
                           strip.background = list(col = gray(0.9)),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25),
                           clip = list(panel = F),
                           layout.heights = list(top.padding = 2)),
       panel = function(...) {
           panel.abline(h = 0, col = gray(0.5), lty = 2)
           panel.bwplot(...,
                        horizontal = F,
                        do.out = F)
           panel.segments(x0 = 1:5 - 0.25,
                          x1 = 1:5 + 0.25,
                          y0 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          y1 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          lwd = 1.5)
           panel.stripplot(...,
                           pch = 21,
                           cex = 1,
                           fill = cols,
                           col = "black",
                           jitter.data = T,
                           amount = 0.1,
                           horizontal = F)
           ## TFT label at top of plot 
           panel.text(x = 3,
                      y = dat_range[2] + 0.7,
                      fontface = "bold",
                      cex = 1.25,
                      labels = gsub(pattern = "_",
                                    replacement = " ",
                                    x = unique(all_data[[2]]$reporter)))
           ## pvals
           panel.text(x = 1,
                      y = dat_range[2] + 0.35,
                      labels = expression(italic("p")),
                      cex = 1.25)
           panel.text(x = 2:5,
                      y = rep(dat_range[2] + 0.35, 4),
                      fontface = "plain",
                      cex = 1.25,
                      labels = c("7.7e-05",
                                 "0.43",
                                 "0.028",
                                 "0.10"))
       })
)
## code end
dev.off()


## -----
## put the variant effects in a simple data frame
allele_effects <- data.frame(allele = levels(all_data[[2]]$strain_final))
allele_effects$gene <- rep("UBR1", nrow(allele_effects))
allele_effects$reporter <- rep(unique(all_data[[2]]$reporter),
                               times = nrow(allele_effects))
allele_effects$effect <-  tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                                 FUN = median)
allele_effects$sem <- tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                             FUN = function(x) {
                                 sd(x) / sqrt(length(x))
})
allele_effects$pvals <- c(1,
                          7.727022e-05,
                          4.295977e-01,
                          2.826016e-02,
                          1.014796e-01)

allele_effects

save(allele_effects,
     file = paste0(frame_dir, "/fine-mapping_UBR1_Asn_fg_effects.R"))

#+END_SRC

* UBR1 Asp Full Gene Fine-Mapping Flow                                    :R:

#+BEGIN_SRC R
## -----
## START USER INPUT
## no trailing '/' at the end!
base_dir  <- "~/data/flow/2021.02.06_UBR1_CRISPR_swap_0659_TFT_flow"
frame_dir <- paste0(base_dir, "/dataframes")
stats_log <- paste0(base_dir, "/results/stats_log")
## END USER INPUT 


## -----
## run the analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/auto_process_N-end_fcs_files.R")

## statistical analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/N-end_stats_runner.R")


## -----
## load the extracted median for ea. parameter and bio. replicate: 
load(file = paste0(frame_dir, "/all_data.R"))

all_data[[2]] <- all_data[[2]][all_data[[2]]$strain != "BY_strain", ]
str(all_data[[2]])
 
all_data[[2]]$strain_final <- droplevels(all_data[[2]]$strain_final)
all_data[[2]]$strain_final <- factor(all_data[[2]]$strain_final,
                                     levels = levels(all_data[[2]]$strain_final)[c(1, 5, 3, 4, 2)])
levels(all_data[[2]]$strain_final)

## -----
## make plots
cols <- ifelse(test = grepl(pattern = ".*BY.*",
                            x = levels(all_data[[2]]$strain_final)),
               yes = "#2166AC77",
               no = "#BF323277")

dat_range <- range(all_data[[2]]$TFT_scaled)
down_range <- dat_range[1] - abs(0.3 * dat_range[1])
up_range <- dat_range[2] + abs(0.2 * dat_range[2])
plot_ranges <- c(down_range, up_range)


## -----
## boxplot w/ pvals 
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_UBR1_Asp_fg_TFT.pdf")
print(
xyplot(all_data[[2]]$TFT_scaled ~ all_data[[2]]$strain_final,
       groups = all_data[[2]]$strain_final,
       ylim = plot_ranges,
       ylab = "UPS Activity Relative to\n BY Allele Median (SD units)",
       xlab = "",
       scales = list(tck = c(1, 0),
                     alternating = F,
                     x = list(labels = c(expression(italic("UBR1")*" BY"),
                                         expression(italic("UBR1")*" RM"),
                                         expression(italic("UBR1")*" RM pr"),
                                         expression(italic("UBR1")*" RM ORF"),
                                         expression(italic("UBR1")*" RM term")),
                              rot = 45,
                              cex = 1.25),
                     y = list(at = seq(from = -4, to = 4, by = 0.5),
                              cex = 1.25)),
       par.settings = list(box.dot = list(pch = "|"),
                           box.umbrella = list(lty = 1,
                                               lwd = 1,
                                               col = gray(0.4)),
                           box.rectangle = list(lty = 1,
                                                lwd = 1,
                                                col = gray(0.4),
                                                fill = gray(0.97)),
                           strip.background = list(col = gray(0.9)),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25),
                           clip = list(panel = F),
                           layout.heights = list(top.padding = 2)),
       panel = function(...) {
           panel.abline(h = 0, col = gray(0.5), lty = 2)
           panel.bwplot(...,
                        horizontal = F,
                        do.out = F)
           panel.segments(x0 = 1:5 - 0.25,
                          x1 = 1:5 + 0.25,
                          y0 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          y1 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          lwd = 1.5)
           panel.stripplot(...,
                           pch = 21,
                           cex = 1,
                           fill = cols,
                           col = "black",
                           jitter.data = T,
                           amount = 0.1,
                           horizontal = F)
           ## TFT label at top of plot 
           panel.text(x = 3,
                      y = dat_range[2] + 0.77,
                      fontface = "bold",
                      cex = 1.25,
                      labels = gsub(pattern = "_",
                                    replacement = " ",
                                    x = unique(all_data[[2]]$reporter)))
           ## pvals
           panel.text(x = 1,
                      y = dat_range[2] + 0.35,
                      labels = expression(italic("p")),
                      cex = 1.25)
           panel.text(x = 2:5,
                      y = rep(dat_range[2] + 0.35, 4),
                      fontface = "plain",
                      cex = 1.25,
                      labels = c("4.6e-4",
                                 "0.33",
                                 "0.34",
                                 "0.55"))
       })
)
## code end
dev.off()


## -----
## put the variant effects in a simple data frame
allele_effects <- data.frame(allele = levels(all_data[[2]]$strain_final))
allele_effects$gene <- rep("UBR1", nrow(allele_effects))
allele_effects$reporter <- rep(unique(all_data[[2]]$reporter),
                               times = nrow(allele_effects))
allele_effects$effect <-  tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                                 FUN = median)
allele_effects$sem <- tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                             FUN = function(x) {
                                 sd(x) / sqrt(length(x))
})
allele_effects$pvals <- c(1,
                          0.0004647284,
                          3.326501e-01,
                          3.418646e-01,
                          5.553711e-01)
allele_effects

save(allele_effects,
     file = paste0(frame_dir, "/fine-mapping_UBR1_Asp_fg_effects.R"))


#+END_SRC

* UBR1 Phe Full Gene Fine-Mapping Flow                                    :R:

#+BEGIN_SRC R
## -----
## START USER INPUT
## no trailing '/' at the end!
base_dir  <- "~/data/flow/2021.02.11_UBR1_CRISPR_swap_0665_TFT_flow"
frame_dir <- paste0(base_dir, "/dataframes")
stats_log <- paste0(base_dir, "/results/stats_log")
## END USER INPUT 


## -----
## run the analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/auto_process_N-end_fcs_files.R")

## statistical analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/N-end_stats_runner.R")


## -----
## load the extracted median for ea. parameter and bio. replicate: 
load(file = paste0(frame_dir, "/all_data.R"))

all_data[[2]] <- all_data[[2]][all_data[[2]]$strain != "BY_strain", ]
str(all_data[[2]])
 
all_data[[2]]$strain_final <- droplevels(all_data[[2]]$strain_final)
all_data[[2]]$strain_final <- factor(all_data[[2]]$strain_final,
                                     levels = levels(all_data[[2]]$strain_final)[c(1, 5, 3, 4, 2)])
levels(all_data[[2]]$strain_final)

## -----
## make plots
cols <- ifelse(test = grepl(pattern = ".*BY.*",
                            x = levels(all_data[[2]]$strain_final)),
               yes = "#2166AC77",
               no = "#BF323277")

dat_range <- range(all_data[[2]]$TFT_scaled)
down_range <- dat_range[1] - abs(0.3 * dat_range[1])
up_range <- dat_range[2] + abs(0.2 * dat_range[2])
plot_ranges <- c(down_range, up_range)


## -----
## boxplot w/ pvals 
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_UBR1_Phe_fg_TFT.pdf")
print(
xyplot(all_data[[2]]$TFT_scaled ~ all_data[[2]]$strain_final,
       groups = all_data[[2]]$strain_final,
       ylim = plot_ranges,
       ylab = "UPS Activity Relative to\n BY Allele Median (SD units)",
       xlab = "",
       scales = list(tck = c(1, 0),
                     alternating = F,
                     x = list(labels = c(expression(italic("UBR1")*" BY"),
                                         expression(italic("UBR1")*" RM"),
                                         expression(italic("UBR1")*" RM pr"),
                                         expression(italic("UBR1")*" RM ORF"),
                                         expression(italic("UBR1")*" RM term")),
                              rot = 45,
                              cex = 1.25),
                     y = list(at = seq(from = -4, to = 4, by = 0.5),
                              cex = 1.25)),
       par.settings = list(box.dot = list(pch = "|"),
                           box.umbrella = list(lty = 1,
                                               lwd = 1,
                                               col = gray(0.4)),
                           box.rectangle = list(lty = 1,
                                                lwd = 1,
                                                col = gray(0.4),
                                                fill = gray(0.97)),
                           strip.background = list(col = gray(0.9)),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25),
                           clip = list(panel = F),
                           layout.heights = list(top.padding = 2)),
       panel = function(...) {
           panel.abline(h = 0, col = gray(0.5), lty = 2)
           panel.bwplot(...,
                        horizontal = F,
                        do.out = F)
           panel.segments(x0 = 1:5 - 0.25,
                          x1 = 1:5 + 0.25,
                          y0 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          y1 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          lwd = 1.5)
           panel.stripplot(...,
                           pch = 21,
                           cex = 1,
                           fill = cols,
                           col = "black",
                           jitter.data = T,
                           amount = 0.1,
                           horizontal = F)
           ## TFT label at top of plot 
           panel.text(x = 3,
                      y = dat_range[2] + 0.7,
                      fontface = "bold",
                      cex = 1.25,
                      labels = gsub(pattern = "_",
                                    replacement = " ",
                                    x = unique(all_data[[2]]$reporter)))
           ## pvals
           panel.text(x = 1,
                      y = dat_range[2] + 0.35,
                      labels = expression(italic("p")),
                      cex = 1.25)
           panel.text(x = 2:5,
                      y = rep(dat_range[2] + 0.35, 4),
                      fontface = "plain",
                      cex = 1.25,
                      labels = c("5.9e-14",
                                 "9.4e-04",
                                 "5.0e-04",
                                 "0.86"))
       })
)
## code end
dev.off()


## -----
## put the variant effects in a simple data frame
allele_effects <- data.frame(allele = levels(all_data[[2]]$strain_final))
allele_effects$gene <- rep("UBR1", nrow(allele_effects))
allele_effects$reporter <- rep(unique(all_data[[2]]$reporter),
                               times = nrow(allele_effects))
allele_effects$effect <-  tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                                 FUN = median)
allele_effects$sem <- tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                             FUN = function(x) {
                                 sd(x) / sqrt(length(x))
})
allele_effects$pvals <- c(1,
                          5.944441e-14,
                          9.358443e-04,
                          5.016622e-04,
                          8.615689e-01)

allele_effects

save(allele_effects,
     file = paste0(frame_dir, "/fine-mapping_UBR1_Phe_fg_effects.R"))

#+END_SRC

* UBR1 Trp Full Gene Fine-Mapping Flow                                    :R:

#+BEGIN_SRC R
## -----
## START USER INPUT
## no trailing '/' at the end!
base_dir  <- "~/data/flow/2021.02.10_UBR1_CRISPR_swap_0663_TFT_flow"
frame_dir <- paste0(base_dir, "/dataframes")
stats_log <- paste0(base_dir, "/results/stats_log")
## END USER INPUT 


## -----
## run the analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/auto_process_N-end_fcs_files.R")

## statistical analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/N-end_stats_runner.R")


## -----
## load the extracted median for ea. parameter and bio. replicate: 
load(file = paste0(frame_dir, "/all_data.R"))

all_data[[2]] <- all_data[[2]][all_data[[2]]$strain != "BY_strain", ]
str(all_data[[2]])
 
all_data[[2]]$strain_final <- droplevels(all_data[[2]]$strain_final)
all_data[[2]]$strain_final <- factor(all_data[[2]]$strain_final,
                                     levels = levels(all_data[[2]]$strain_final)[c(1, 5, 3, 4, 2)])
levels(all_data[[2]]$strain_final)

## -----
## make plots
cols <- ifelse(test = grepl(pattern = ".*BY.*",
                            x = levels(all_data[[2]]$strain_final)),
               yes = "#2166AC77",
               no = "#BF323277")

dat_range <- range(all_data[[2]]$TFT_scaled)
down_range <- dat_range[1] - abs(0.3 * dat_range[1])
up_range <- dat_range[2] + abs(0.2 * dat_range[2])
plot_ranges <- c(down_range, up_range)


## -----
## boxplot w/ pvals 
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_UBR1_Trp_fg_TFT.pdf")
print(
xyplot(all_data[[2]]$TFT_scaled ~ all_data[[2]]$strain_final,
       groups = all_data[[2]]$strain_final,
       ylim = plot_ranges,
       ylab = "UPS Activity Relative to\n BY Allele Median (SD units)",
       xlab = "",
       scales = list(tck = c(1, 0),
                     alternating = F,
                     x = list(labels = c(expression(italic("UBR1")*" BY"),
                                         expression(italic("UBR1")*" RM"),
                                         expression(italic("UBR1")*" RM pr"),
                                         expression(italic("UBR1")*" RM ORF"),
                                         expression(italic("UBR1")*" RM term")),
                              rot = 45,
                              cex = 1.25),
                     y = list(at = seq(from = -4, to = 4, by = 0.5),
                              cex = 1.25)),
       par.settings = list(box.dot = list(pch = "|"),
                           box.umbrella = list(lty = 1,
                                               lwd = 1,
                                               col = gray(0.4)),
                           box.rectangle = list(lty = 1,
                                                lwd = 1,
                                                col = gray(0.4),
                                                fill = gray(0.97)),
                           strip.background = list(col = gray(0.9)),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25),
                           clip = list(panel = F),
                           layout.heights = list(top.padding = 2)),
       panel = function(...) {
           panel.abline(h = 0, col = gray(0.5), lty = 2)
           panel.bwplot(...,
                        horizontal = F,
                        do.out = F)
           panel.segments(x0 = 1:5 - 0.25,
                          x1 = 1:5 + 0.25,
                          y0 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          y1 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          lwd = 1.5)
           panel.stripplot(...,
                           pch = 21,
                           cex = 1,
                           fill = cols,
                           col = "black",
                           jitter.data = T,
                           amount = 0.1,
                           horizontal = F)
           ## TFT label at top of plot 
           panel.text(x = 3,
                      y = dat_range[2] + 0.55,
                      fontface = "bold",
                      cex = 1.25,
                      labels = gsub(pattern = "_",
                                    replacement = " ",
                                    x = unique(all_data[[2]]$reporter)))
           ## pvals
           panel.text(x = 1,
                      y = dat_range[2] + 0.3,
                      labels = expression(italic("p")),
                      cex = 1.25)
           panel.text(x = 2:5,
                      y = rep(dat_range[2] + 0.3, 4),
                      fontface = "plain",
                      cex = 1.25,
                      labels = c("1.8e-19",
                                 "5.8e-16",
                                 "9.9e-12",
                                 "0.18"))
       })
)
## code end
dev.off()


## -----
## put the variant effects in a simple data frame
allele_effects <- data.frame(allele = levels(all_data[[2]]$strain_final))
allele_effects$gene <- rep("UBR1", nrow(allele_effects))
allele_effects$reporter <- rep(unique(all_data[[2]]$reporter),
                               times = nrow(allele_effects))
allele_effects$effect <-  tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                                 FUN = median)
allele_effects$sem <- tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                             FUN = function(x) {
                                 sd(x) / sqrt(length(x))
})
allele_effects$pvals <- c(1,
                          1.792741e-19,
                          5.768327e-16,
                          9.883915e-12,
                          1.799362e-01)

allele_effects

save(allele_effects,
     file = paste0(frame_dir, "/fine-mapping_UBR1_Trp_fg_effects.R"))
#+END_SRC

* UBR1 Trp Promoter Fine-Mapping Flow                                     :R:

#+BEGIN_SRC R
## -----
## START USER INPUT
## no trailing '/' at the end!
base_dir  <- "~/data/flow/2021.03.19_UBR1_single_variant_0663_TFT_freezer_fresh"
frame_dir <- paste0(base_dir, "/dataframes")
stats_log <- paste0(base_dir, "/results/stats_log")
## END USER INPUT 


## -----
## run the analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/auto_process_N-end_fcs_files.R")

## statistical analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/N-end_stats_runner.R")


## -----
## load the extracted median for ea. parameter and bio. replicate: 
load(file = paste0(frame_dir, "/all_data.R"))

all_data[[2]] <- all_data[[2]][all_data[[2]]$strain != "BY_strain", ]
str(all_data[[2]])
 
all_data[[2]]$strain_final <- droplevels(all_data[[2]]$strain_final)
all_data[[2]]$strain_final <- factor(all_data[[2]]$strain_final,
                                     levels = levels(all_data[[2]]$strain_final)[c(1, 4, 2, 5, 3)])
levels(all_data[[2]]$strain_final)

## -----
## make plots
cols <- ifelse(test = grepl(pattern = ".*BY.*",
                            x = levels(all_data[[2]]$strain_final)),
               yes = "#2166AC77",
               no = "#BF323277")

dat_range <- range(all_data[[2]]$TFT_scaled)
down_range <- dat_range[1] - abs(0.3 * dat_range[1])
up_range <- dat_range[2] + abs(0.125 * dat_range[2])
plot_ranges <- c(down_range, up_range)


## -----
## boxplot w/ pvals 
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_UBR1_Trp_TFT.pdf")
print(
xyplot(all_data[[2]]$TFT_scaled ~ all_data[[2]]$strain_final,
       groups = all_data[[2]]$strain_final,
       ylim = plot_ranges,
       ylab = "UPS Activity Relative to\n BY Allele Median (SD units)",
       xlab = "",
       scales = list(tck = c(1, 0),
                     alternating = F,
                     x = list(labels = c(expression(italic("UBR1")*" BY"),
                                         expression(italic("UBR1")*" RM"),
                                         expression(italic("UBR1")*" RM pr"),
                                         expression(italic("UBR1")*" -469A>T"),
                                         expression(italic("UBR1")*" -197T>G")),
                              rot = 45,
                              cex = 1.25),
                     y = list(at = seq(from = -3, to = 3, by = 0.5),
                              cex = 1.25)),
       par.settings = list(box.dot = list(pch = "|"),
                           box.umbrella = list(lty = 1,
                                               lwd = 1,
                                               col = gray(0.4)),
                           box.rectangle = list(lty = 1,
                                                lwd = 1,
                                                col = gray(0.4),
                                                fill = gray(0.97)),
                           strip.background = list(col = gray(0.9)),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25),
                           clip = list(panel = F),
                           layout.heights = list(top.padding = 2)),
       panel = function(...) {
           panel.abline(h = 0, col = gray(0.5), lty = 2)
           panel.bwplot(...,
                        horizontal = F,
                        do.out = F)
           panel.segments(x0 = 1:5 - 0.25,
                          x1 = 1:5 + 0.25,
                          y0 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          y1 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          lwd = 1.5)
           panel.stripplot(...,
                           pch = 21,
                           cex = 1,
                           fill = cols,
                           col = "black",
                           jitter.data = T,
                           amount = 0.1,
                           horizontal = F)
           ## TFT label at top of plot 
           panel.text(x = 3,
                      y = dat_range[2] + 0.32,
                      fontface = "bold",
                      cex = 1.25,
                      labels = gsub(pattern = "_",
                                    replacement = " ",
                                    x = unique(all_data[[2]]$reporter)))
           ## pvals
           panel.text(x = 1,
                      y = dat_range[2] + 0.15,
                      labels = expression(italic("p")),
                      cex = 1.25)
           panel.text(x = 2:5,
                      y = rep(dat_range[2] + 0.15, 4),
                      fontface = "plain",
                      cex = 1.25,
                      labels = c("1.4e-21",
                                 "5.0e-19",
                                 "3.4e-19",
                                 "0.12"))
       })
)
## code end
dev.off()


## -----
## put the variant effects in a simple data frame
allele_effects <- data.frame(allele = levels(all_data[[2]]$strain_final))
allele_effects$gene <- rep("UBR1", nrow(allele_effects))
allele_effects$reporter <- rep(unique(all_data[[2]]$reporter),
                               times = nrow(allele_effects))
allele_effects$effect <-  tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                                 FUN = median)
allele_effects$sem <- tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                             FUN = function(x) {
                                 sd(x) / sqrt(length(x))
})
allele_effects$pvals <- c(1,
                          1.396067e-21,
                          5.005946e-19,
                          3.376931e-19,
                          1.199616e-01)

allele_effects

save(allele_effects,
     file = paste0(frame_dir, "/fine-mapping_UBR1_Trp_effects.R"))
#+END_SRC

* UBR1 Phe Promoter Fine-Mapping Flow                                     :R:

#+BEGIN_SRC R
## -----
## START USER INPUT
## no trailing '/' at the end!
base_dir  <- "~/data/flow/2021.03.19_UBR1_single_variant_0665_TFT_freezer_fresh"
frame_dir <- paste0(base_dir, "/dataframes")
stats_log <- paste0(base_dir, "/results/stats_log")
## END USER INPUT 


## -----
## run the analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/auto_process_N-end_fcs_files.R")

## statistical analysis
source("~/emacs/N-end_Rule_QTL_paper/scripts/N-end_stats_runner.R")


## -----
## load the extracted median for ea. parameter and bio. replicate: 
load(file = paste0(frame_dir, "/all_data.R"))

all_data[[2]] <- all_data[[2]][all_data[[2]]$strain != "BY_strain", ]
str(all_data[[2]])
 
all_data[[2]]$strain_final <- droplevels(all_data[[2]]$strain_final)
all_data[[2]]$strain_final <- factor(all_data[[2]]$strain_final,
                                     levels = levels(all_data[[2]]$strain_final)[c(1, 4, 2, 5, 3)])
levels(all_data[[2]]$strain_final)

## -----
## make plots
cols <- ifelse(test = grepl(pattern = ".*BY.*",
                            x = levels(all_data[[2]]$strain_final)),
               yes = "#2166AC77",
               no = "#BF323277")

dat_range <- range(all_data[[2]]$TFT_scaled)
down_range <- dat_range[1] - abs(0.3 * dat_range[1])
up_range <- dat_range[2] + abs(0.125 * dat_range[2])
plot_ranges <- c(down_range, up_range)


## -----
## boxplot w/ pvals 
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_UBR1_Phe_TFT.pdf")
print(
xyplot(all_data[[2]]$TFT_scaled ~ all_data[[2]]$strain_final,
       groups = all_data[[2]]$strain_final,
       ylim = plot_ranges,
       ylab = "UPS Activity Relative to\n BY Allele Median (SD units)",
       xlab = "",
       scales = list(tck = c(1, 0),
                     alternating = F,
                     x = list(labels = c(expression(italic("UBR1")*" BY"),
                                         expression(italic("UBR1")*" RM"),
                                         expression(italic("UBR1")*" RM pr"),
                                         expression(italic("UBR1")*" -469A>T"),
                                         expression(italic("UBR1")*" -197T>G")),
                              rot = 45,
                              cex = 1.25),
                     y = list(at = seq(from = -3, to = 3, by = 0.5),
                              cex = 1.25)),
       par.settings = list(box.dot = list(pch = "|"),
                           box.umbrella = list(lty = 1,
                                               lwd = 1,
                                               col = gray(0.4)),
                           box.rectangle = list(lty = 1,
                                                lwd = 1,
                                                col = gray(0.4),
                                                fill = gray(0.97)),
                           strip.background = list(col = gray(0.9)),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25),
                           clip = list(panel = F),
                           layout.heights = list(top.padding = 2)),
       panel = function(...) {
           panel.abline(h = 0, col = gray(0.5), lty = 2)
           panel.bwplot(...,
                        horizontal = F,
                        do.out = F)
           panel.segments(x0 = 1:5 - 0.25,
                          x1 = 1:5 + 0.25,
                          y0 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          y1 = tapply(X = all_data[[2]]$TFT_scaled,
                                      INDEX = all_data[[2]]$strain_final,
                                      FUN = median),
                          lwd = 1.5)
           panel.stripplot(...,
                           pch = 21,
                           cex = 1,
                           fill = cols,
                           col = "black",
                           jitter.data = T,
                           amount = 0.1,
                           horizontal = F)
           ## TFT label at top of plot 
           panel.text(x = 3,
                      y = dat_range[2] + 0.4,
                      fontface = "bold",
                      cex = 1.25,
                      labels = gsub(pattern = "_",
                                    replacement = " ",
                                    x = unique(all_data[[2]]$reporter)))
           ## pvals
           panel.text(x = 1,
                      y = dat_range[2] + 0.15,
                      labels = expression(italic("p")),
                      cex = 1.25)
           panel.text(x = 2:5,
                      y = rep(dat_range[2] + 0.15, 4),
                      fontface = "plain",
                      cex = 1.25,
                      labels = c("2.3e-15",
                                 "3.6e-11",
                                 "5.8e-16",
                                 "0.64"))
       })
)
## code end
dev.off()


## -----
## put the variant effects in a simple data frame
allele_effects <- data.frame(allele = levels(all_data[[2]]$strain_final))
allele_effects$gene <- rep("UBR1", nrow(allele_effects))
allele_effects$reporter <- rep(unique(all_data[[2]]$reporter),
                               times = nrow(allele_effects))
allele_effects$effect <-  tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                                 FUN = median)
allele_effects$sem <- tapply(X = all_data[[2]]$TFT_scaled,
                                 INDEX = all_data[[2]]$strain_final,
                             FUN = function(x) {
                                 sd(x) / sqrt(length(x))
})
allele_effects$pvals <- c(1,
                          2.328107e-15,
                          3.602095e-11,
                          5.774777e-16,
                          6.483263e-01)

allele_effects


save(allele_effects,
     file = paste0(frame_dir, "/fine-mapping_UBR1_Phe_effects.R"))
#+END_SRC

* QTG UBR1 Barchart                                                       :R:

#+BEGIN_SRC R :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/UBR1_QTG_barchart.R
## -----
## setup
library("lattice")
dirs <- c("~/data/flow/2021.02.12_UBR1_CRISPR_swap_0657_TFT_flow",
          "~/data/flow/2021.02.06_UBR1_CRISPR_swap_0659_TFT_flow",
          "~/data/flow/2021.02.11_UBR1_CRISPR_swap_0665_TFT_flow",
          "~/data/flow/2021.02.10_UBR1_CRISPR_swap_0663_TFT_flow")


## -----
## read in allele effects and create dataframe
frame_dirs <- paste0(dirs, "/dataframes")

effect_list <- list()

for(x in 1:length(frame_dirs)){

    ## load in allele effects for ea. reporter 
    load(dir(frame_dirs[x],
             pattern = ".*effects.R",
             full.names = T),
         verbose = T)
    
    ## assign to the list
    effect_list[[x]] <- allele_effects

    ## remove object before going on to next reporter 
    rm(allele_effects)

}

effects <- do.call("rbind", effect_list)


## -----
## subset and order
effects_sub <- effects[effects$allele != "BY_full", ]

effects_sub$allele_drop <- droplevels(effects_sub$allele)

effects_sub$allele_ordered <- factor(effects_sub$allele,
                                     levels = levels(effects_sub$allele_drop)[c(1, 3, 2, 4)])

effects_final <- effects_sub[order(effects_sub$allele_ordered,
                                   decreasing = T), ]

effects_final <- effects_final[ , -7]

effects_final


## -----
## plot
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_summary_full_gene_barchart.pdf")
barchart(1:nrow(effects_final) ~ effects_final$effect,
         origin = 0,
         ylab = "",
         xlab = "UPS Activity Relative to BY Allele Median (SD units)",
         xlim = c(-2.4, 2.2),
         box.ratio = 2,
         scales = list(tck = c(1, 0),
                       y = list(at = seq(from = 2.5, to = 14.5, by = 4),
                                labels = c(expression(italic("UBR1")*" RM term"),
                                           expression(italic("UBR1")*" RM ORF"),
                                           expression(italic("UBR1")*" RM pr"),
                                           expression(italic("UBR1")*" RM")),
                                cex = 1.25),
                       x = list(cex = 1.25,
                                at = seq(from = -4.5, to = 4.5, by = 0.5))),
         par.settings = list(par.xlab.text = list(cex = 1.25),
                             par.ylab.text = list(cex = 1.25),
                             clip = list(panel = F),
                             layout.widths = list(right.padding = 4.5),
                             layout.heights = list(top.padding = 5)),
         panel = function(...) {
             panel.abline(h = seq(from = 4.5, to = 12.5, by = 4),
                          lty = 1, lwd = 1, col = gray(0))
             panel.abline(v = 0, lwd = 1.5, col = gray(0.4))
             panel.barchart(...,
                            col = c("tan1", "tan1", "tomato", "tomato"),
                            reference = F)
             panel.segments(x0 = effects_final$effect - effects_final$sem,
                            x1 = effects_final$effect + effects_final$sem,
                            y0 = 1:nrow(effects_final),
                            y1 = 1:nrow(effects_final),
                            lty = 1, col = gray(0.2))
             panel.text(x = 2.45,
                        y = 1:16,
                        labels = c("Asn", "Asp", "Phe", "Trp"),
                        cex = 1.25)
             ## TFT
             panel.text(x = 2.45,
                        y = 17,
                        labels = "TFT",
                        fontface = "bold",
                        cex = 1.25)
             ## legend
             panel.rect(xleft = c(-2.3, 0.1),
                        xright = c(-2, 0.4),
                        ytop = c(18.5, 18.5),
                        ybottom = c(17.8, 17.8),
                        col = c("tan1", "tomato"))
             panel.text(x = c(-1.15, 1.27),
                        y = c(18.15, 18.15),
                        labels = c("Type I Arg/N-end",
                                   "Type II Arg/N-end"),
                        fontface = "plain",
                        cex = 1.25)
             ## pvals
             panel.text(x = -2,
                        y = 17,
                        labels = expression(italic("p")*"-value"), 
                        cex = 1.25)
             panel.text(x = c(-2.05, -2.05, -2.1, -2.1, -2.05, -2.1, -2.05, -2.1, -2.15),
                        y = c(16:11, 8, 7, 5),
                        labels = c("1.8e-19", "5.9e-14",  "4.6e-4", "7.7e-5",
                                   "5.8e-16", "9.4e-4",
                                   "9.9e-12", "5.0e-4", "0.028"),
                        fontface = "plain",
                        cex = 1.1)
         })
## code end 
dev.off()

## -----
## single variant fine-mapping 


## -----
## setup
library("lattice")
dirs <- c("~/data/flow/2021.03.19_UBR1_single_variant_0665_TFT_freezer_fresh",
          "~/data/flow/2021.03.19_UBR1_single_variant_0663_TFT_freezer_fresh")


## -----
## read in allele effects and create dataframe
frame_dirs <- paste0(dirs, "/dataframes")

effect_list <- list()

for(x in 1:length(frame_dirs)){

    ## load in allele effects for ea. reporter 
    load(dir(frame_dirs[x],
             pattern = ".*effects.R",
             full.names = T),
         verbose = T)
    
    ## assign to the list
    effect_list[[x]] <- allele_effects

    ## remove object before going on to next reporter 
    rm(allele_effects)

}

effects <- do.call("rbind", effect_list)


## -----
## subset and order
effects_sub <- effects[effects$allele != "BY_full", ]
effects_sub <- effects_sub[effects_sub$allele != "RM_full", ]

effects_sub$allele_drop <- droplevels(effects_sub$allele)

effects_sub$allele_ordered <- factor(effects_sub$allele,
                                     levels = levels(effects_sub$allele_drop)[c(3, 1, 2)])

effects_final <- effects_sub[order(effects_sub$allele_ordered,
                                   decreasing = T), ]

effects_final <- effects_final[ , -7]

## reporter ordering 
## effects_final <- effects_final[c(2, 1, 4, 3, 6, 5, 8, 7), ]

## -----
## plot
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_summary_single_variant_barchart_final.pdf",
    height = 4.5, width = 7)
barchart(1:nrow(effects_final) ~ effects_final$effect,
         origin = 0,
         ylab = "",
         xlab = "UPS Activity Relative to BY Allele Median (SD units)",
         xlim = c(-1.6, 1.6),
         box.ratio = 2,
         scales = list(tck = c(1, 0),
                       y = list(at = seq(from = 1.5, to = 5.5, by = 2),
                                labels = c(expression(italic("UBR1")*" RM -197A>C"),
                                           expression(italic("UBR1")*" RM -469A>T"),
                                           expression(italic("UBR1")*" RM pr")),
                                cex = 1.25),
                       x = list(cex = 1.25,
                                at = seq(from = -4.5, to = 4.5, by = 0.5))),
         par.settings = list(par.xlab.text = list(cex = 1.25),
                             par.ylab.text = list(cex = 1.25),
                             clip = list(panel = F),
                             layout.widths = list(right.padding = 4.5),
                             layout.heights = list(top.padding = 5)),
         panel = function(...) {
             panel.abline(h = seq(from = 2.5, to = 4.5, by = 2),
                          lty = 1, lwd = 1, col = gray(0))
             panel.abline(v = 0, lwd = 1.5, col = gray(0.4))
             panel.barchart(...,
                            col = "tomato",
                            reference = F)
             panel.segments(x0 = effects_final$effect - effects_final$sem,
                            x1 = effects_final$effect + effects_final$sem,
                            y0 = 1:nrow(effects_final),
                            y1 = 1:nrow(effects_final),
                            lty = 1, col = gray(0.2))
             panel.text(x = 1.8,
                        y = 1:6,
                        labels = c("Phe", "Trp"),
                        cex = 1.25)
             ## TFT
             panel.text(x = 1.8,
                        y = 6.87,
                        labels = "TFT",
                        fontface = "bold",
                        cex = 1.25)
             ## ## legend
             ## panel.rect(xleft = c(-2.2, 0.1),
             ##            xright = c(-1.9, 0.4),
             ##            ytop = c(18.5, 18.5),
             ##            ybottom = c(17.8, 17.8),
             ##            col = c("tan1", "tomato"))
             ## panel.text(x = c(-1.05, 1.27),
             ##            y = c(18.15, 18.15),
             ##            labels = c("Type I Arg/N-end",
             ##                       "Type II Arg/N-end"),
             ##            fontface = "plain",
             ##            cex = 1.25)
             ## pvals
             panel.text(x = -1.27,
                        y = 6.87,
                        labels = expression(italic("p")*"-value"),
                        cex = 1.25)
             panel.text(x = c(rep(-1.3, 4)),
                        y = c(6:3),
                        labels = c("5.0e-19", "3.6e-11",
                                   "3.4e-19", "5.8e-16"),
                        fontface = "plain",
                        cex = 1.1)
         })
## code end 
dev.off()
#+END_SRC

* QTG DOA10, UBC6, NTA1 Barcharts                                         :R:

#+BEGIN_SRC R :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/other_QTG_barchart.R
## -----
## DOA10


## -----
## setup
library("lattice")
dirs <- c("~/data/flow/2022.04.06_DOA10_Thr_1043_CRISPR_swap_flow",
          "~/data/flow/2021.07.20_DOA10_Gly_1047_CRISPR_swap_flow")

## -----
## read in allele effects and create dataframe
frame_dirs <- paste0(dirs, "/dataframes")

effect_list <- list()

for(x in 1:length(frame_dirs)){

    ## load in allele effects for ea. reporter 
    load(dir(frame_dirs[x],
             pattern = ".*effects.R",
             full.names = T),
         verbose = T)
    
    ## assign to the list
    effect_list[[x]] <- allele_effects

    ## remove object before going on to next reporter 
    rm(allele_effects)

}

effects <- do.call("rbind", effect_list)


## -----
## subset and order
effects_sub <- effects[effects$allele != "BY_full", ]

effects_sub$allele_drop <- droplevels(effects_sub$allele)

effects_sub$allele_ordered <- factor(effects_sub$allele,
                                     levels = levels(effects_sub$allele_drop)[c(4, 1, 2, 3)])

effects_final <- effects_sub[order(effects_sub$allele_ordered,
                                   decreasing = F), ]

effects_final <- effects_final[ , -7]

effects_final


## -----
## plot
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_summary_DOA10_barchart.pdf",
    height = 4.5, width = 7)
barchart(1:nrow(effects_final) ~ effects_final$effect,
         origin = 0,
         ylab = "",
         xlab = "UPS Activity Relative to BY Allele Median (SD units)",
         xlim = c(-0.6, 2.2),
         box.ratio = 2,
         scales = list(tck = c(1, 0),
                       y = list(at = seq(from = 1.5, to = 7.5, by = 2),
                                labels = c(expression(italic("DOA10")*" Y1186F"),
                                           expression(italic("DOA10")*" K1012N"),
                                           expression(italic("DOA10")*" Q410E"),
                                           expression(italic("DOA10")*" RM")),
                                cex = 1.25),
                       x = list(cex = 1.25,
                                at = seq(from = -4.5, to = 4.5, by = 0.5))),
         par.settings = list(par.xlab.text = list(cex = 1.25),
                             par.ylab.text = list(cex = 1.25),
                             clip = list(panel = F),
                             layout.widths = list(right.padding = 4.5),
                             layout.heights = list(top.padding = 5)),
         panel = function(...) {
             panel.abline(h = seq(from = 2.5, to = 7.5, by = 2),
                          lty = 1, lwd = 1, col = gray(0))
             panel.abline(v = 0, lwd = 1.5, col = gray(0.4))
             panel.barchart(...,
                            col = c("plum1"),
                            reference = F)
             panel.segments(x0 = effects_final$effect - effects_final$sem,
                            x1 = effects_final$effect + effects_final$sem,
                            y0 = 1:nrow(effects_final),
                            y1 = 1:nrow(effects_final),
                            lty = 1, col = gray(0.2))
             panel.text(x = 2.35,
                        y = 1:8,
                        labels = c("Thr", "Gly"),
                        cex = 1.25)
             ## TFT
             panel.text(x = 2.35,
                        y = 9,
                        labels = "TFT",
                        fontface = "bold",
                        cex = 1.25)
             ## legend
             ## pvals
             panel.text(x = -0.35,
                        y = 9,
                        labels = expression(italic("p")*"-value"),
                        cex = 1.25)
             panel.text(x = c(-0.36, -0.36, -0.36, -0.39, -0.36, -0.36),
                        y = c(8, 7, 6, 4, 2, 1),
                        labels = c("8.8e-13", "2.6e-16",
                                   "4.8e-10",
                                   "1.8e-7",
                                   "2.6e-16", "8.7e-13"),
                        fontface = "plain",
                        cex = 1.1)
         })
## code end 
dev.off()


## -----
## UBC6



## -----
## setup
library("lattice")
dirs <- c("~/data/flow/2021.07.16_UBC6_Ala_1049_CRISPR_swap_flow",
          "~/data/flow/2021.07.15_UBC6_Thr_1043_CRISPR_swap_flow")

## -----
## read in allele effects and create dataframe
frame_dirs <- paste0(dirs, "/dataframes")

effect_list <- list()

for(x in 1:length(frame_dirs)){

    ## load in allele effects for ea. reporter 
    load(dir(frame_dirs[x],
             pattern = ".*effects.R",
             full.names = T),
         verbose = T)
    
    ## assign to the list
    effect_list[[x]] <- allele_effects

    ## remove object before going on to next reporter 
    rm(allele_effects)

}

effects <- do.call("rbind", effect_list)


## -----
## subset and order
effects_sub <- effects[effects$allele != "BY_full", ]

effects_sub$allele_drop <- droplevels(effects_sub$allele)

effects_sub$allele_ordered <- factor(effects_sub$allele,
                                     levels = levels(effects_sub$allele_drop)[c(2, 3, 1, 4)])

effects_final <- effects_sub[order(effects_sub$allele_ordered,
                                   decreasing = T), ]

effects_final <- effects_final[ , -7]

effects_final


## -----
## plot
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_summary_UBC6_barchart.pdf",
    height = 4.5, width = 7)
barchart(1:nrow(effects_final) ~ effects_final$effect,
         origin = 0,
         ylab = "",
         xlab = "UPS Activity Relative to BY Allele Median (SD units)",
         xlim = c(-0.26, 1.2),
         box.ratio = 2,
         scales = list(tck = c(1, 0),
                       y = list(at = seq(from = 1.5, to = 7.5, by = 2),
                                labels = c(expression(italic("UBC6")*" RM term"),
                                           expression(italic("UBC6")*" D229G"),
                                           expression(italic("UBC6")*" RM pr"),
                                           expression(italic("UBC6")*" RM")),
                                cex = 1.25),
                       x = list(cex = 1.25,
                                at = seq(from = 0, to = 1, by = 0.25),
                                labels = c("0", "0.25", "0.50", "0.75", "1.0"))),
         par.settings = list(par.xlab.text = list(cex = 1.25),
                             par.ylab.text = list(cex = 1.25),
                             clip = list(panel = F),
                             layout.widths = list(right.padding = 4.5),
                             layout.heights = list(top.padding = 5)),
         panel = function(...) {
             panel.abline(h = seq(from = 2.5, to = 7.5, by = 2),
                          lty = 1, lwd = 1, col = gray(0))
             panel.abline(v = 0, lwd = 1.5, col = gray(0.4))
             panel.barchart(...,
                            col = c("plum1"),
                            reference = F)
             panel.segments(x0 = effects_final$effect - effects_final$sem,
                            x1 = effects_final$effect + effects_final$sem,
                            y0 = 1:nrow(effects_final),
                            y1 = 1:nrow(effects_final),
                            lty = 1, col = gray(0.2))
             panel.text(x = 1.27,
                        y = 1:8,
                        labels = c("Ala", "Thr"),
                        cex = 1.25)
             ## TFT
             panel.text(x = 1.27,
                        y = 9,
                        labels = "TFT",
                        fontface = "bold",
                        cex = 1.25)
             ## legend
             ## pvals
             panel.text(x = -0.125,
                        y = 9,
                        labels = expression(italic("p")*"-value"),
                        cex = 1.25)
             panel.text(x = c(-0.15, -0.16, -0.16, -0.16, -0.175),
                        y = c(8, 7, 4, 3, 1),
                        labels = c("3.0e-18", "3.4e-8",
                                   "6.1e-9", "1.6e-9",
                                   "0.011"),
                        fontface = "plain",
                        cex = 1.1)
         })
## code end 
dev.off()


## -----
## NTA1


## -----
## setup
library("lattice")
dirs <- c("~/data/flow/2021.07.07_NTA1_Asp_0659_CRISPR_swap_flow",
          "~/data/flow/2021.07.08_NTA1_Asn_0657_CRISPR_swap_flow")

## -----
## read in allele effects and create dataframe
frame_dirs <- paste0(dirs, "/dataframes")

effect_list <- list()

for(x in 1:length(frame_dirs)){

    ## load in allele effects for ea. reporter 
    load(dir(frame_dirs[x],
             pattern = ".*effects.R",
             full.names = T),
         verbose = T)
    
    ## assign to the list
    effect_list[[x]] <- allele_effects

    ## remove object before going on to next reporter 
    rm(allele_effects)

}

effects <- do.call("rbind", effect_list)


## -----
## subset and order
effects_sub <- effects[effects$allele != "BY_full", ]

effects_sub$allele_drop <- droplevels(effects_sub$allele)

effects_sub$allele_ordered <- factor(effects_sub$allele,
                                     levels = levels(effects_sub$allele_drop)[c(3, 4, 1, 2)])

effects_final <- effects_sub[order(effects_sub$allele_ordered,
                                   decreasing = T), ]

effects_final <- effects_final[ , -7]

effects_final <- effects_final[effects_final$reporter != "Asp_TFT", ]

effects_final


## -----
## plot
pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/fine-mapping_summary_NTA1_barchart.pdf",
    height = 3.5, width = 7)
barchart(1:nrow(effects_final) ~ effects_final$effect,
         origin = 0,
         ylab = "",
         xlab = "UPS Activity Relative to BY Allele Median (SD units)",
         xlim = c(-1, 1.8),
         box.ratio = 2,
         scales = list(tck = c(1, 0),
                       y = list(at = 1:4,
                                labels = c(expression(italic("NTA1")*" E129G"),
                                           expression(italic("NTA1")*" D111E"),
                                           expression(atop(NA, atop(italic("NTA1")*" RM",
                                                      "promoter"))),
                                           expression(italic("NTA1")*" RM")),
                                cex = 1.25),
                       x = list(cex = 1.25,
                                at = seq(from = -4, to = 4, by = 0.5))),
         par.settings = list(par.xlab.text = list(cex = 1.25),
                             par.ylab.text = list(cex = 1.25),
                             clip = list(panel = F),
                             layout.widths = list(right.padding = 4.5),
                             layout.heights = list(top.padding = 5)),
         panel = function(...) {
             panel.abline(h = seq(from = 1.5, to = 3.5, by = 1),
                          lty = 1, lwd = 1, col = gray(0))
             panel.abline(v = 0, lwd = 1.5, col = gray(0.4))
             panel.barchart(...,
                            col = c("tan1"),
                            reference = F)
             panel.segments(x0 = effects_final$effect - effects_final$sem,
                            x1 = effects_final$effect + effects_final$sem,
                            y0 = 1:nrow(effects_final),
                            y1 = 1:nrow(effects_final),
                            lty = 1, col = gray(0.2))
             ## panel.text(x = 1.95,
             ##            y = 1:4,
             ##            labels = c("Asn"),
             ##            cex = 1.25)
             ## TFT
             panel.text(x = 0.5,
                        y = 4.84,
                        labels = "Asn TFT",
                        fontface = "bold",
                        cex = 1.25)
             ## legend
             ## pvals
             panel.text(x = -0.75,
                        y = 4.87,
                        labels = expression(italic("p")*"-value"),
                        cex = 1.25)
             panel.text(x = c(-0.78, -0.81, -0.78),
                        y = c(4, 2, 1),
                        labels = c("3.8e-11", "7.6e-3", "2.1e-10"),
                        fontface = "plain",
                        cex = 1.1)
         })
## code end 
dev.off()
#+END_SRC

* Analysis of Causal Variants                                             :R:

** Plot Motifs                                                             :R:
#+BEGIN_SRC R
## install.packages("ggseqlogo")
require("ggseqlogo")
require(ggplot2)

## hap5 position weight matrix from YeTFaSCo
A <- c(0.0, 0.0, 0.25, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0)
T <- c(0.5, 0.5, 0.25, 1.0, 1.0, 1.0, 0.5, 0.5, 0.5, 1.0, 0.0)
G <- c(0.0, 0.5, 0.25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
C <- c(0.5, 0.0, 0.25, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 1.0)

hap5 <- as.matrix(rbind(A, T, G, C))

pdf(file = "~/emacs/N-end_Rule_QTL_paper/figures_drafts/hap5_binding_logo.pdf",
    width = 12, height = 6)
    ggseqlogo(hap5, method = "bits")
dev.off()
#+END_SRC

** Derived vs. Ancestral Allele Analysis at QTGs/QTNs                      :R:

#+BEGIN_SRC R

## load the dataframe w/ information on whether the RM allele is derived
load(file = "~/emacs/N-end_Rule_QTL_paper/variant_analysis/R_RMDerived_withInfo_200718.RData")

str(RMDerived_withInfo)
## CHROM = chromosome
## POS = variant location
## ID = ?
## REF = reference allele
## ALT_allele = alternative allele
## RMDerived = whether RM allele is derived (T = yes, F = no, NA = unknown)

## simplify the name of the dataset
dat <- RMDerived_withInfo

## information on our QTGs for extracting variants from defined genomic ranges 
genes <- c("UBR1", "DOA10", "UBC6", "NTA1")
chr <- c("chrVII", "chrIX", "chrV", "chrX")
## genomic ranges for QTGs; go 500 bp up/down to get promoter/terminator
gene_lower_value <- c(859901, 296050, 359562, 553476) - 500
gene_upper_value <- c(865753, 300009, 360314, 554849) + 500

qtg_table <- data.frame(gene = genes,
                        chr = chr,
                        lower = gene_lower_value,
                        upper = gene_upper_value)

qtg_out <- list()

for(i in 1:nrow(qtg_table)) {

    ## extract the information for each gene's genomic range;
    ## add to a list that we'll then collapse to a dataframe
    q <- dat[dat$CHROM == qtg_table[i, "chr"] &
             dat$POS > qtg_table[i, "lower"] &
             dat$POS < qtg_table[i, "upper"], ]
    q$gene <- rep(qtg_table[i, "gene"], nrow(q))
    qtg_out[[i]] <- q

}

qtg_final <- do.call("rbind", qtg_out)

## save output
write.table(x = qtg_final,
            file = "~/emacs/N-end_Rule_QTL_paper/variant_analysis/QTG_variant_state_table.csv",
            append = F, quote = F, sep = "\t",
            row.names = T, col.names = T)
#+END_SRC

** Population Allele Frequencies At QTGs/QTNs                              :R:

*** Variant Information Table for Calculating Population Allele Frequencies

#+NAME: QTG_variant_information_table
| Position | Chr    | Gene  |
|----------+--------+-------|
|   359292 | chrV   | UBC6  |
|   359471 | chrV   | UBC6  |
|   360247 | chrV   | UBC6  |
|   360409 | chrV   | UBC6  |
|   554957 | chrX   | NTA1  |
|   554999 | chrX   | NTA1  |
|   554517 | chrX   | NTA1  |
|   554464 | chrX   | NTA1  |
|   553441 | chrX   | NTA1  |
|   298782 | chrIX  | DOA10 |
|   296974 | chrIX  | DOA10 |
|   296453 | chrIX  | DOA10 |
|   866222 | chrVII | UBR1  |
|   865950 | chrVII | UBR1  |
|   865578 | chrVII | UBR1  |
|   865499 | chrVII | UBR1  |
|   862491 | chrVII | UBR1  |
|   862303 | chrVII | UBR1  |
|   861978 | chrVII | UBR1  |
|   861475 | chrVII | UBR1  |
|   861190 | chrVII | UBR1  |
|   860821 | chrVII | UBR1  |
|   859825 | chrVII | UBR1  |
|   859808 | chrVII | UBR1  |
|   859804 | chrVII | UBR1  |
|   859745 | chrVII | UBR1  |
|   859719 | chrVII | UBR1  |
|   859584 | chrVII | UBR1  |
|   859580 | chrVII | UBR1  |
|   859422 | chrVII | UBR1  |
|   859418 | chrVII | UBR1  |

*** Calculate QTG Population Allele Frequencies From 1,000 Yeast Genomes Project Data :R:

#+NAME: QTG_allele_frequency_calculation :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/QTG_AF_calc.R
#+BEGIN_SRC R
## module load R/3.6.0
## R

## -----
## setup
## load the big, or a reduced VCF, call it "af_data"
base_dir <- "~/emacs/N-end_Rule_QTL_paper/variant_analysis/"
load(paste0(base_dir, "PeterGenotypesRMAlt_200505.RData"))

## simplify the name for subsequent work 
af_data <- PeterGenotypesRMAlt

str(af_data)
summary(af_data)

## load a table with each variant's chromosome and position
variants <- read.csv(file = paste0(base_dir, "QTG_variant_locations.csv"),
                     header = T, sep = ",", quote = "",
                     stringsAsFactors = F)

## calculate the population allele frequency for ea. variant in the table 
ret <- vector(length = nrow(variants))
for (i in 1:nrow(variants)) {

    ## assign a variant to 'x'
    x  <- variants[i, ]

    ## get the row corresponding to the variant from the 1,011 matrix
    gt <- af_data[af_data$CHROM == x[1, "Chr"] &
                  as.numeric(af_data$POS) == as.numeric(x[1, "Position"]), ]

    ## if we unambiguously get a single variant ('if(nrow(gt) == 1)'),
    if(nrow(gt) == 1){

        thisINFO <- thisGT[,"INFO"]

        ## double 'strsplit' call here to go from, e.g.,
        ## "1/1:1,247:248:99:.:.:10388,717,0" to "1", "1"
        RMAlleles <- strsplit(strsplit(gt$AAA, ":")[[1]][1], "/")[[1]]
        
        RMAltAllele <- as.numeric(RMAlleles[which(!RMAlleles %in% c("0"))][1])

        ## the matrix already contains the allele frequencies, so
        ## just get the corresponding field, 'strsplit' it, and convert
        ## from chr to numeric; the allele frequency is in the first
        ## element of the list and the 2nd element of the vector 
        thisAFField <- strsplit(as.character(thisINFO), ";")[[1]][2]
        if(grepl(pattern = "AF=", x = thisAFField)){
            ret[i] <- as.numeric(strsplit(strsplit(thisAFField, "=")[[1]][2], ",")[[1]][RMAltAllele])
        }
    }
}

var_info <- list()

## build the final table and write out 
variants$pop_RM_AF <- ret

write.table(x = variants,
            file = paste0(base_dir, "QTG_allele_frequency_table.csv"),
            append = F, quote = F, sep = ",",
            row.names = T, col.names = T)


## -----
## make a table for creating the variant history tree
for (i in 1:nrow(variants)) {

    ## assign a variant to 'x'
    x  <- variants[i, ]

    ## get the row corresponding to the variant from the 1,011 matrix
    gt <- af_data[af_data$CHROM == x[1, "Chr"] &
                  as.numeric(af_data$POS) == as.numeric(x[1, "Position"]), ]

    ## returns a vector of genotypes for the rows of the matrix
    ## we'll later cbind these to create the dataframe that we need
    var_info[[i]] <- sapply(X = gt[, 10:ncol(gt)],
                            FUN = function(strain) {
                                strsplit(x = strain, split = ":")[[1]][1]
                                })
}

var_info_final <- do.call("cbind", var_info)
var_info_final <- as.data.frame(var_info_final)
    
## these will become the rownames for the final table
strain_list <- colnames(gt[, 10:ncol(gt)])

## these will be the column names for the final table
variant_list <- paste0(variants$Position, "_",
                       variants$Gene) 

rownames(var_info_final) <- strain_list
colnames(var_info_final) <- variant_list

write.table(x = var_info_final,
            file = paste0(base_dir, "QTN_tree_data.csv"),
            append = F, quote = F, sep = ",",
            row.names = T, col.names = T)

#+END_SRC

** Tree Diagrams of Causal Variants                           :R:
#+BEGIN_SRC R :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/QTN_tree_diagrams.R
## author: Christian Brion 2019-12-18

## -----
## setup and load packages
library("plyr")
library("reshape2")
library("ape")
library("tidyverse")

base_dir <- "~/emacs/N-end_Rule_QTL_paper/variant_analysis/"
plots_dir <- paste0(base_dir, "plots/") 

tree <- read.tree(paste0(base_dir, "1011_matrix.tree.newick"))

## get information about the 1011 Sc strains, provided 
Strain1002 <- read.csv(paste0(base_dir, "1002Strains.txt"),
                       header = T, 
                       sep="\t", 
                       comment.char = "", 
                       quote = "")

## rotate one branch of the tree for better presentation
tree <- rotate(tree, 1126, polytom = c(1, 2))

## this makes the basic tree plot 
plot(tree, type = "unrooted",
     use.edge.length = TRUE, #ploting the tree as control
     node.pos = NULL,
     show.tip.label = FALSE,
     show.node.label = FALSE,
     edge.color = "black",
     edge.width = 1,
     edge.lty = 1, font = 3,
     cex = par("cex"), adj = NULL,
     srt = 0, no.margin = FALSE,
     root.edge = FALSE,
     label.offset = 0, underscore = FALSE,
     x.lim = NULL, y.lim = NULL, direction = "rightwards",
     lab4ut = NULL, tip.color = "black", plot = TRUE,
     rotate.tree = 0, open.angle = 0, node.depth = 1,
     align.tip.label = FALSE)


## -----
## find RM and BY on the tree
tree2 <- tree
tree2$tip.label[!(tree2$tip.label %in% c("AAA","ADT"))] <- " "

my_red <- "#B65050"
my_blu <- "#446F9A"
my_pur <- "#7C416B"

colbranch<-c(rep("lightgrey",nrow(tree2$edge)))
for (i in 1:nrow(tree2$edge)) {
  edgeN<-c(1:nrow(tree2$edge))[tree2$edge[,2]==i]
  if (i <= length(tree2$tip.label)) {
    if (tree2$tip.label[i]=="AAA") {
      colbranch[edgeN]<- my_red
    } else if (tree2$tip.label[i]=="ADT") {
      colbranch[edgeN]<- my_blu
    } else {
      colbranch[edgeN]<-"lightgrey"
    }
  }
}

## produce the tree with the position of the parental strains
plot(tree, type = "unrooted",
     use.edge.length = TRUE,
     node.pos = NULL,
     show.tip.label = FALSE,
     show.node.label = FALSE,
     edge.color = colbranch,
     edge.width = 1,
     edge.lty = 1, font = 3,
     cex = par("cex"), adj = NULL,
     srt = 0, no.margin = FALSE,
     root.edge = FALSE,
     label.offset = 0, underscore = FALSE,
     x.lim = NULL, y.lim = NULL, direction = "rightwards",
     lab4ut = NULL, tip.color = "black", plot = TRUE,
     rotate.tree = 0, open.angle = 0, node.depth = 1,
     align.tip.label = FALSE,main="parent")

## load the genotypes at the variants of interest
tree_data <- read.table(paste0(base_dir, "QTN_tree_data.csv"),
                        header = T, sep = ",", stringsAsFactors = F)
## load(paste0(base_dir, "IRA2_varGenosStringsOnly_210716.RData"))

## provide strains information to the table above
tree_table <- merge(Strain1002, tree_data, by.x = "Standardized.name", by.y = 0, all.x=T)
head(tree_table)

dcast(table2, Clades~var3) #allelic count per cluster

## add a joined vector for the three variants
table2$all3vars <- paste(table2$var3, table2$var4, table2$var6, sep="_")

## clade coutns for these:
dcast(table2[!str_detect(table2$all3vars, "\\."),], Clades~all3vars) #allelic count per cluster


#=======================
#coloring the edge of the tree to follow variant evolution

#QTNs <- c("var3", "var4", "var6")

QTNs <- colnames(tree_table)[20:50]

for(QTN in QTNs){

if(QTN %in%  colnames(tree_table)[20:50]){
    colbranch<-c(rep("grey", nrow(tree$edge)))
    for (i in 1:nrow(tree$edge)) {
        ## coloring the last edges (top of the
        ## tree) according to the allele of the
        ## site of interest in the corresponding strains
      edgeN<-c(1:nrow(tree$edge))[tree$edge[,2]==i]
      if (i <= length(tree$tip.label)) {
        if (is.na(tree_table[,QTN][tree_table$Standardized.name==tree$tip.label[i]])) {
          colbranch[edgeN] <- "grey"
        } else if (tree_table[,QTN][tree_table$Standardized.name==tree$tip.label[i]]=="0/0") {
          colbranch[edgeN] <- my_blu
        } else if (tree_table[,QTN][tree_table$Standardized.name==tree$tip.label[i]]=="1/1") {
          colbranch[edgeN] <- my_red
        } else if (tree_table[,QTN][tree_table$Standardized.name==tree$tip.label[i]]=="0/1") {
          colbranch[edgeN] <- my_pur
        }
      }
    }
}

    ## next section colors in branches
    ## according to their tips, if unambiguous
    ## print(date())
    for (j in 1:100) {
        ##coloring the edges within the tree according to
        ##the colors of the two out-coming edges, going
        ## down at each iteration (100 iterations)
  for (i in (length(tree$tip.label)+1):nrow(tree$edge)) {
    edgeN<-c(1:nrow(tree$edge))[tree$edge[,2]==i]
    if (length(levels(as.factor(colbranch[tree$edge[,1]==i])))==1) {
        ## control same color of the two out-coming edges
        colbranch[edgeN]<-levels(as.factor(colbranch[tree$edge[,1]==i]))
        ## give this color to the inner-edge (if not, stay black)
    }
  }
}
## print(date()) runs in 10–15secs

    ## generating the tree with the edges colored
    ## by allele version in a svg format (for Inkskape)
    pdf(paste0(plots_dir, "tree_",
               strsplit(QTN, "X")[[1]][2],
               ".pdf"),
        width = 10, height = 10)
    
plot(tree, type = "unrooted", use.edge.length = TRUE,
     node.pos = NULL, show.tip.label = FALSE, show.node.label = FALSE,
     edge.color = colbranch, edge.width = 0.75, edge.lty = 1, font = 3,
     cex = par("cex"), adj = NULL, srt = 0, no.margin = FALSE,
     root.edge = FALSE, label.offset = 0, underscore = FALSE,
     x.lim = NULL, y.lim = NULL, direction = "rightwards",
     lab4ut = NULL, tip.color = "black", plot = TRUE,
     rotate.tree = 0, open.angle = 0, node.depth = 1,
     align.tip.label = FALSE,
     main = strsplit(QTN, "X")[[1]][2])
## legend("bottomright", inset=0.3,
##     legend=c("0/0_0/0_0/0", "1/1_1/1_1/1", "1/1_1/1_0/0", "0/0_1/1_1/1", "0/0_1/1_0/0", "0/1_1/1_1/1", "0/1_1/1_0/0", "0/1_1/1_0/1", "0/1_0/1_0/1", "other")
##     ,fill=c("blue", "red", "firebrick1", "royalblue", "royalblue3", "hotpink", "hotpink1", "hotpink2", "hotpink3", "grey"))
dev.off()
}


#+END_SRC
* RNA-Seq and Proteomics Analysis                                         :R:

** Sample Information Table
|  N | File         | Background | Variants  | Genotype     | i7   | i7_barcode | i5   | i5_barcode |
|----+--------------+------------+-----------+--------------+------+------------+------+------------|
|  1 | wild-type_01 | BY         | wild-type | BY_wild-type | i701 | ATTACTCG   | i501 | AGGCTATA   |
|  2 | mutant_01    | BY         | mutant    | BY_mutant    | i702 | TCCGGAGA   | i501 | AGGCTATA   |
|  3 | wild-type_02 | BY         | wild-type | BY_wild-type | i703 | CGCTCATT   | i502 | GCCTCTAT   |
|  4 | mutant_02    | BY         | mutant    | BY_mutant    | i704 | GAGATTCC   | i502 | GCCTCTAT   |
|  5 | wild-type_03 | BY         | wild-type | BY_wild-type | i705 | ATTCAGAA   | i503 | AGGATAGG   |
|  6 | mutant_03    | BY         | mutant    | BY_mutant    | i706 | GAATTCGT   | i503 | AGGATAGG   |
|  7 | wild-type_04 | BY         | wild-type | BY_wild-type | i707 | CTGAAGCT   | i504 | TCAGAGCC   |
|  8 | mutant_04    | BY         | mutant    | BY_mutant    | i708 | TAATGCGC   | i504 | TCAGAGCC   |
|  9 | wild-type_05 | BY         | wild-type | BY_wild-type | i709 | CGGCTATG   | i505 | CTTCGCCT   |
| 10 | mutant_05    | BY         | mutant    | BY_mutant    | i710 | TCCGCGAA   | i505 | CTTCGCCT   |
#+TBLFM: $1 = @# - 1
#+TBLFM: $2 = '(if (= (% $1 2) 0) (concat "mutant_0" (format "%s" (/ $1 2))) (concat "wild-type_0" (format "%s" (ceiling (/ $1 1.9)))));L
#+TBLFM: $4 = '(if (= (% $1 2) 0) "mutant" "wild-type");L
#+TBLFM: $5 = '(if (= (% $1 2) 0) "BY_mutant" "BY_wild-type");L

** ubr1_trimmomatic.sh                                                  :BASH:

*** ubr1_trimmomatic.sh
#+NAME: ubr1_trimmomatic.sh
#+BEGIN_SRC bash :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/ubr1_trimmomatic.sh
#!/bin/bash -l
#SBATCH --time=15:00:00
#SBATCH --ntasks=8
#SBATCH --mem=10g
#SBATCH --tmp=10g
#SBATCH -p ram256g
#SBATCH -n 2
#SBATCH --ntasks=8
#SBATCH --mail-type=ALL
#SBATCH --mail-user=mahlon@umn.edu
#SBATCH -o /home/albertf/mahlon/UBR1_RNA-seq_analysis/trimmomatic/std_out_log
#SBATCH -e /home/albertf/mahlon/UBR1_RNA-seq_analysis/trimmomatic/std_err_log

## -----
## setup

## variables
## [1] project directory
## determine which system we're on and set accordingly
if [ "$(hostname)" = mahlon-linux ]
then
    project_dir=~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/
else
    project_dir=~/UBR1_RNA-seq_analysis/
fi

## [2] directory w/ fastq files
input_dir=/home/albertf/data_release/umgc/nextseq/210728_VH00601_2_AAAGV5CHV/Albert_Project_023/

## [3] directory for trimmomatic output
output_dir=${project_dir}trimmomatic/
if [ ! -d ${output_dir} ]
then
    mkdir -v ${output_dir}
fi

## [4] sample listing that we use to read fastq files
## input_files=${project_dir}"test.txt"
input_files=${project_dir}"UBR1_sample_indices.txt"


## -----
## load software
module load trimmomatic/0.39


## -----
## run trimmomatic
## IFS = "internal field separator"; how bash
## recognizes word boundaries when splitting
## sequences of character strings; here we set
## it to tab to match the table we supply
## see: https://unix.stackexchange.com/questions/18886/why-is-while-ifs-read-used-so-often-instead-of-ifs-while-read
## for more information.  Here, the input is
## specified at the end of the loop
# ls -l ${input_dir}
TRIMMOMATIC=/panfs/roc/msisoft/trimmomatic/0.39/

while IFS=$'\t' read -r -a lineArray
do
echo "sample: ${lineArray[0]}"
echo "genotype: ${lineArray[1]}"
java -jar ${TRIMMOMATIC}trimmomatic-0.39.jar PE -threads 14 \
${input_dir}${lineArray[1]}*R1*.fastq.gz \
${input_dir}${lineArray[1]}*R2*.fastq.gz \
-baseout "${output_dir}${lineArray[1]}.fastq.gz" \
ILLUMINACLIP:${TRIMMOMATIC}adapters/TruSeq3-PE-2.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36
done < $input_files

## parameters:
## LEADING: remove bases from the beginning w/ quality < 3
## TRAILING: remove bases from the end w/ quality < 3
## SLIDINGWINDOW: cut once the average quality within a 4 bp win < 15
## MINLEN: remove reads w/ length < 36

## ls -l ${output_dir}

## seems there's multiple adapter files, may need to use
## the other one if this doesn't work.  see:
## https://www.biostars.org/p/250425/
## cat $TRIMMOMATIC/adapters/TruSeq3-PE-2.fa
## cat $TRIMMOMATIC/adapters/TruSeq3-PE.fa

#+END_SRC

*** Run ubr1_trimmomatic.sh
#+NAME: run_trimmomatic
#+BEGIN_SRC bash

## sync files to msi
rsync -avz ~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/ \
      mahlon@mesabi.msi.umn.edu:~/UBR1_RNA-seq_analysis/

## login to MSI
ssh mahlon@mesabi.msi.umn.edu
ssh mesabi

## setup for running the script
cd ~/UBR1_RNA-seq_analysis/
ls -alh
chmod u+r+x ubr1_trimmomatic.sh

## run the script w/ slurm scheduler
## no '-p' specified here - instead we let slurm auto-select
## a partition per: https://www.msi.umn.edu/slurm/pbs-conversion
echo "" > /home/albertf/mahlon/UBR1_RNA-seq_analysis/trimmomatic/std_out_log
echo "" > /home/albertf/mahlon/UBR1_RNA-seq_analysis/trimmomatic/std_err_log
cat /home/albertf/mahlon/UBR1_RNA-seq_analysis/trimmomatic/std_{out,err}_log

## run the script and direct output to logs
sbatch ubr1_trimmomatic.sh >> /home/albertf/mahlon/UBR1_RNA-seq_analysis/trimmomatic/std_out_log 2>> /home/albertf/mahlon/UBR1_RNA-seq_analysis/trimmomatic/std_err_log

## check status of the job (shows name, time, node, etc....)
squeue -u mahlon

## check the results
cat ~/UBR1_RNA-seq_analysis/trimmomatic/std_out_log
cat ~/UBR1_RNA-seq_analysis/trimmomatic/std_err_log
ls -alh ~/UBR1_RNA-seq_analysis/trimmomatic/
squeue -u mahlon
## the fastq files increase in size over time as
## trimmomatic runs, so seems that trying to run
## the script outside of slurm was causing it to
## to get killed before completion.  This would
## explain why there's files in the output dir,
## but you never see the completion message from
## trimmomatic

## You may see a high number of forward-only surviving
## reads relative to reverse-only reads.  This is b/c
## trimmomatic's default behaviour is to drop the reverse
## reads when it trims adapters, so you get forward reads
## only surviving as a result.  see:
## https://www.biostars.org/p/325174/#325193

## there's multiple types of TruSeq 3 files for
## trimmomatic, but seems we want TruSeq-3-PE-2.fa:
## https://www.biostars.org/p/323087/
## TruSeq-3-PE-2.fa contains some additional sequences
## which find partial adapters in unusual location/orientation.

## cat TruSeq3-PE-2.fa
## >PrefixPE/1
## TACACTCTTTCCCTACACGACGCTCTTCCGATCT
## >PrefixPE/2
## GTGACTGGAGTTCAGACGTGTGCTCTTCCGATCT
## >PE1
## TACACTCTTTCCCTACACGACGCTCTTCCGATCT
## >PE1_rc
## AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGTA
## >PE2
## GTGACTGGAGTTCAGACGTGTGCTCTTCCGATCT
## >PE2_rc
## AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC

## cat TruSeq3-PE.fa
## TruSeq3-PE.fa
## >PrefixPE/1
## TACACTCTTTCCCTACACGACGCTCTTCCGATCT
## >PrefixPE/2
## GTGACTGGAGTTCAGACGTGTGCTCTTCCGATCT

#+END_SRC

** 'fastp' Processing of Input Files                                    :BASH:

*** ubr1_fastp.sh
#+BEGIN_SRC bash :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/ubr1_fastp.sh
#!/bin/bash -l
#SBATCH --time=15:00:00
#SBATCH --ntasks=8
#SBATCH --mem=10g
#SBATCH --tmp=10g
#SBATCH -p ram256g
#SBATCH -n 2
#SBATCH --ntasks=8
#SBATCH --mail-type=ALL
#SBATCH --mail-user=mahlon@umn.edu
#SBATCH -o /home/albertf/mahlon/UBR1_RNA-seq_analysis/fastp/fastp_std_out_log
#SBATCH -e /home/albertf/mahlon/UBR1_RNA-seq_analysis/fastp/fastp_std_err_log

## -----
## setup

## [1] project directory
## determine which system we're on and set accordingly
if [ "$(hostname)" = mahlon-linux ]
then
    project_dir=~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/
else
    project_dir=~/UBR1_RNA-seq_analysis/
fi

## [2] directory w/ fastq files
input_dir=/home/albertf/data_release/umgc/nextseq/210728_VH00601_2_AAAGV5CHV/Albert_Project_023/

## [3] directory for fastp output
output_dir=${project_dir}fastp/output/
if [ ! -d ${output_dir} ]
then
    mkdir -v ${output_dir}
fi

## [4] sample listing that we use to read fastq files
## input_files=${project_dir}"test.txt"
input_files=${project_dir}"UBR1_sample_indices.txt"

## [5] logs
touch ${project_dir}fastp/fastp_std_{out,err}_log
out_log=${project_dir}fastp/fastp_std_out_log
err_log=${project_dir}fastp/fastp_std_err_log
echo "" > ${out_log}
echo "" > ${err_log}

## [6] fastp
fastp=~/.local/bin/fastp

## -----
## run fastp 
cd ${project_dir}fastp

while IFS=$'\t' read -r -a lineArray
do
echo "running fastp on sample: ${lineArray[0]}" >> ${out_log}
echo "running fastp genotype: ${lineArray[1]}" >> ${out_log}
${fastp} --in1 ${input_dir}${lineArray[1]}*R1*.fastq.gz \
--in2 ${input_dir}${lineArray[1]}*R2*.fastq.gz \
--out1 ${output_dir}${lineArray[1]}_fastp_out_R1.fastq.gz \
--out2 ${output_dir}${lineArray[1]}_fastp_out_R2.fastq.gz \
--cut_front --cut_tail --cut_mean_quality 15 \
--length_required 36 \
--dedup --detect_adapter_for_pe \
--trim_poly_g --trim_poly_x \
--report_title "${lineArray[1]}_fastp_report.html" \
--html "${lineArray[1]}_fastp_report.html"
done < ${input_files}
#+END_SRC 
*** run 'ubr1_fastp.sh'

#+NAME: run 'ubr1_fastp.sh'
#+BEGIN_SRC bash
rsync -avzn ~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/fastp/ \
mahlon@mesabi.msi.umn.edu:~/UBR1_RNA-seq_analysis/fastp/

chmod a+x ~/UBR1_RNA-seq_analysis/fastp/ubr1_fastp.sh

## run the script and direct output to logs
sbatch ubr1_fastp.sh >> /home/albertf/mahlon/UBR1_RNA-seq_analysis/fastp/fastp_std_out_log 2>> /home/albertf/mahlon/UBR1_RNA-seq_analysis/fastqc/fastp_std_err_log

## check status of the job (shows name, time, node, etc....)
squeue -u mahlon

## check the results
cat /home/albertf/mahlon/UBR1_RNA-seq_analysis/fastp/fastp_std_out_log
cat /home/albertf/mahlon/UBR1_RNA-seq_analysis/fastp/fastp_std_err_log

## file size in 'output' should increase as the run proceeds...
ls -alh
ls -alh output

## compare w/ trimmomatic results
ls -alh ../trimmomatic

## compare file size of processed to unprocessed
ls -alh ${input_dir}
#+END_SRC 

*** ubr1_fastp_kallisto.sh

#+NAME: ubr1_fastp_kallisto.sh
#+BEGIN_SRC bash :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/ubr1_fastp_kallisto.sh
#!/bin/bash -l
#SBATCH --time=35:00:00
#SBATCH --ntasks=8
#SBATCH --mem=10g
#SBATCH --tmp=10g
#SBATCH -p ram256g
#SBATCH -n 2
#SBATCH --ntasks=8
#SBATCH --mail-type=ALL
#SBATCH --mail-user=mahlon@umn.edu
#SBATCH -o /home/albertf/mahlon/UBR1_RNA-seq_analysis/fastp/kallisto_std_out_log
#SBATCH -e /home/albertf/mahlon/UBR1_RNA-seq_analysis/fastp/kallisto_std_err_log

## -----
## setup

## variables
## [1] project directory
## determine which system we're on and set accordingly
if [ "$(hostname)" = mahlon-linux ]
then
    project_dir=~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/
else
    project_dir=~/UBR1_RNA-seq_analysis/
fi
echo ${project_dir}

## [2] directory w/ fastq files
input_dir=${project_dir}fastp/output/
ls -alh ${input_dir}

## [3] directory for kallisto output
output_dir=${project_dir}fastp/kallisto_out/
if [ ! -d ${output_dir} ]
then
    mkdir -v ${output_dir}
fi
ls -alh ${output_dir}


## [4] sample listing that we use to read fastq files
## input_files=${project_dir}"test.txt"
input_files=${project_dir}"UBR1_sample_indices.txt"
head ${input_files}


## [5] kallisto command - using version 46.1, which is 
## not available on MSI
kallisto=~/kallisto/kallisto
${kallisto} version

## [6] log files
touch ${project_dir}/fastp/kallisto_std_{out,err}_log
out_log=${project_dir}/fastp/kallisto_std_out_log


## -----
## build the index
## '-i' specifies the index to be built
${kallisto} index -i "cerevisiae_transcripts.idx" \
${project_dir}/kallisto/Saccharomyces_cerevisiae.R64-1-1.cdna.all.fa


## -----
## run kallisto
## IFS = "internal field separator"; how bash
## recognizes word boundaries when splitting
## sequences of character strings; here we set
## it to tab to match the table we supply
## see: https://unix.stackexchange.com/questions/18886/why-is-while-ifs-read-used-so-often-instead-of-ifs-while-read
## for more information.  Here, the input is
## specified at the end of the loop
## ls -l ${input_dir}

## kallisto parameters
## quant: run the quantification algorithm
## -i: specifies the index (get from the kallisto page)
## -t: threads, here 8
## -l: est'd avg. fragment length
## -s: est'd std dev of fragment length, here 30 bp
## -b: n. bootstrap samples, here 100
## -o: where to write output to 
## NOTE: avg. frag. length and length sd automatically estimated
## for paired-end data, so can drop these parameters
cd ${project_dir}/fastp/

while IFS=$'\t' read -r -a lineArray
do
echo "$( date +%Y.%m.%d_%T ) running kallisto on sample: ${lineArray[1]}" > ${out_log}
${kallisto} quant \
--index=s_cer_transcriptome.idx \
-t 8 --rf-stranded -b 100  \
-o ${output_dir}${lineArray[1]}"_kallisto_out" \
${input_dir}${lineArray[1]}*R1*.fastq.gz \
${input_dir}${lineArray[1]}*R2*.fastq.gz \
--genomebam --gtf Saccharomyces_cerevisiae.R64-1-1.96.gtf \
--chromosomes chrLengths_ensemblFormat.txt
done < ${input_files}

#+END_SRC

*** Run 'ubr1_fastp_kallisto.sh'
#+BEGIN_SRC bash
## sync files to msi
rsync -avz ~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/fastp/ \
      mahlon@mesabi.msi.umn.edu:~/UBR1_RNA-seq_analysis/

## login to MSI
ssh mahlon@mesabi.msi.umn.edu
ssh mesabi

## run the script w/ slurm scheduler
## no '-p' specified here - instead we let slurm auto-select
## a partition per: https://www.msi.umn.edu/slurm/pbs-conversion
touch ~/UBR1_RNA-seq_analysis/fastp/kallisto_std_{out,err}_log
echo "" > ~/UBR1_RNA-seq_analysis/fastp/kallisto_std_out_log
echo "" > ~/UBR1_RNA-seq_analysis/fastp/kallisto_std_err_log
cat ~/UBR1_RNA-seq_analysis/fastp/kallisto_std_{out,err}_log

## setup for running the script
cd ~/UBR1_RNA-seq_analysis/fastp/
ls -alh
chmod u+r+x ubr1_fastp_kallisto.sh

## run the script and direct output to logs
sbatch ubr1_fastp_kallisto.sh >> ~/UBR1_RNA-seq_analysis/fastp/kallisto_std_out_log 2>> ~/UBR1_RNA-seq_analysis/fastp/kallisto_std_err_log

## check status of the job (shows name, time, node, etc....)
squeue -u mahlon

## check the results
cat ~/UBR1_RNA-seq_analysis/fastp/kallisto_std_out_log
cat ~/UBR1_RNA-seq_analysis/fastp/kallisto_std_err_log
ls -alh ~/UBR1_RNA-seq_analysis/fastp/kallisto_out/
ls -alh ~/UBR1_RNA-seq_analysis/fastp/kallisto_out/wild-type_01_kallisto_out/

## inspect some output 
head ~/UBR1_RNA-seq_analysis/fastp/kallisto_out/wild-type_01_kallisto_out/abundance.tsv

## compare to trimmomatic processed reads
head ~/UBR1_RNA-seq_analysis/kallisto/wild-type_01_kallisto_out/abundance.tsv


## -----
## post-file re-naming
base_dir=~/UBR1_RNA-seq_analysis/kallisto/

names='wild-type mutant'

for i in {1..5};
do
for n in ${names};
do
    d=${n}"_"0${i}"_kallisto_out"
    a=${n}"_"0${i}"_abundance.tsv"
    p=${n}"_"0${i}"_pseudoalignments.bam"
    b=${n}"_"0${i}"_pseudoalignments.bam.bai"
    cp -v ${base_dir}${d}/abundance.tsv ${base_dir}${d}/${a}
    cp -v ${base_dir}${d}/pseudoalignments.bam ${base_dir}${d}/${p}
    cp -v ${base_dir}${d}/pseudoalignments.bam.bai ${base_dir}${d}/${b}
    ## need to rename both pseudoalignment files for rseqc later 
done
done

## check the results to make sure everything looks good
ls -alh ${base_dir}mutant_01_kallisto_out
ls -alh ${base_dir}wild-type_05_kallisto_out

#+END_SRC 

*** ubr1_fastp_rseqc.sh                                                  :BASH:
#+NAME: ubr1_fastp_rseqc.sh
#+BEGIN_SRC bash :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/ubr1_fastp_rseqc.sh
#!/bin/bash -l
#SBATCH --time=35:00:00
#SBATCH --ntasks=8
#SBATCH --mem=10g
#SBATCH --tmp=10g
#SBATCH -p ram256g
#SBATCH -n 2
#SBATCH --ntasks=8
#SBATCH --mail-type=ALL
#SBATCH --mail-user=mahlon@umn.edu
#SBATCH -o /home/albertf/mahlon/UBR1_RNA-seq_analysis/fastp/rseqc/rseqc_std_err_log
#SBATCH -e /home/albertf/mahlon/UBR1_RNA-seq_analysis/fastp/rseqc/rseqc_std_out_log


## -----
## setup
## http://rseqc.sourceforge.net/#download-rseqc
## suggests installing using the python installer:
## which pip
## pip install RSeQC
## note that the scripts get installed in:
## ~/.local/bin/ after the above pip command

## have to load R so that geneBody_coverage.py
## can create the output pdf 
module load R/3.6.0

base_dir=/home/albertf/mahlon/UBR1_RNA-seq_analysis/fastp/
ls -alh ${base_dir}
mkdir -v ${base_dir}rseqc/
rseq_dir=${base_dir}rseqc/
## ls -alh ${rseq_dir}

## -----
## rsync as needed
## move files from home to msi
## rsync -avzn ~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/rseqc/
## mahlon@mesabi.msi.umn.edu:/home/albertf/mahlon/UBR1_RNA-seq_analysis/kallisto/rseqc

## move files from msi to home
## rsync -avzn mahlon@mesabi.msi.umn.edu:/home/albertf/mahlon/UBR1_RNA-seq_analysis/kallisto/rseqc
## ~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/rseqc/


## -----
## logs
r_std_out=${rseq_dir}rseqc_std_out_log
r_std_err=${rseq_dir}rseqc_std_err_log
touch ${r_std_out}
touch ${r_std_err}
echo "" > ${r_std_out}
echo "" > ${r_std_err}
cat ${r_std_out}
cat ${r_std_err}


## -----
## run rseqc scripts
## variables
gene_bod=~/.local/bin/geneBody_coverage.py
## ${gene_bod} --version
gene_ref=/home/albertf/mahlon/UBR1_RNA-seq_analysis/kallisto/rseqc/ensemblGenes_fromUCSC_mod.bed
## head ${gene_ref}

## -----
## 'tin.py'
## measures the 'transcript integrity number' (TIN):
## TIN, an algorithm that is able to measure RNA integrity at transcript level.
## calculates a score (0 <= TIN <= 100) for each expressed transcript
## rgeneseqc.sourceforge.net/#download-rseqc
tin=~/.local/bin/tin.py
${tin} --version

names='wild-type mutant'

for i in {1..5};
do
for n in ${names};
do
input=${n}_0${i}
echo "running tin.py on sample:" ${input} >> ${r_std_out}
## write the output to the appropriate dir
cd ${base_dir}kallisto_out/${input}_kallisto_out
echo "$( date ) running geneBody_coverage.py on sample:" ${input} >> ${r_std_out}
${tin} -i ${base_dir}kallisto_out/${input}_kallisto_out/${input}*pseudoalignments.bam -r ${gene_ref} \
>> ${r_std_out} 2>> ${r_std_err}
done
done


## -----
## 'geneBody_coverage.py':
## calculate the RNA-seq reads coverage over gene body.
## rgeneseqc.sourceforge.net/#download-rseqc
## the output here is a pdf of a line graph 
## showing the coverage across transcripts 

cd ${rseq_dir}

names='wild-type mutant'

for i in {1..5};
do
for n in ${names};
do
input=${n}_0${i}
echo "running geneBody_coverage.py on sample:" ${input} >> ${r_std_out}
${gene_bod} -i ${base_dir}/kallisto_out/${input}_kallisto_out/${input}*pseudoalignments.bam \
-r ${gene_ref} -o ${input} >> ${r_std_out} 2>> ${r_std_err}
done
done
#+END_SRC

*** Run 'ubr1_fastp_rseqc.sh'
#+BEGIN_SRC bash
## sync files to msi
rsync -avz ~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/fastp/ \
      mahlon@mesabi.msi.umn.edu:~/UBR1_RNA-seq_analysis/fastp/

## login to MSI
ssh mahlon@mesabi.msi.umn.edu
ssh mesabi

## run the script w/ slurm scheduler
## no '-p' specified here - instead we let slurm auto-select
## a partition per: https://www.msi.umn.edu/slurm/pbs-conversion
touch     ~/UBR1_RNA-seq_analysis/fastp/rseqc/rseqc_std_{out,err}_log
echo "" > ~/UBR1_RNA-seq_analysis/fastp/rseqc/rseqc_std_out_log
echo "" > ~/UBR1_RNA-seq_analysis/fastp/rseqc/rseqc_std_err_log
cat       ~/UBR1_RNA-seq_analysis/fastp/rseqc/rseqc_std_{out,err}_log

## setup for running the script
cd ~/UBR1_RNA-seq_analysis/fastp/
ls -alh
chmod u+r+x ubr1_fastp_rseqc.sh

## run the script and direct output to logs
sbatch ubr1_fastp_rseqc.sh >> ~/UBR1_RNA-seq_analysis/fastp/rseqc_std_out_log 2>> ~/UBR1_RNA-seq_analysis/fastp/rseqc_std_err_log

## check status of the job (shows name, time, node, etc....)
squeue -u mahlon

## check the results
ls -alh ~/UBR1_RNA-seq_analysis/fastp/rseqc
cat ~/UBR1_RNA-seq_analysis/fastp/rseqc/rseqc_std_out_log
cat ~/UBR1_RNA-seq_analysis/fastp/rseqc/rseqc_std_err_log
cat ~/UBR1_RNA-seq_analysis/fastp/rseqc/log.txt
ls -alh ~/UBR1_RNA-seq_analysis/fastp/rseqc

## TIN files 
ls -alh ~/UBR1_RNA-seq_analysis/fastp/kallisto_out/wild-type_01_kallisto_out/
ls -alh ~/UBR1_RNA-seq_analysis/fastp/kallisto_out/mutant_01_kallisto_out/

cat /home/albertf/mahlon/UBR1_RNA-seq_analysis/fastp/rseqc_std_err_log
cat /home/albertf/mahlon/UBR1_RNA-seq_analysis/fastp/rseqc_std_out_log


## -----
## post-file re-naming
out_dir=~/UBR1_RNA-seq_analysis/fastp/fastp_kallisto_out/
base_dir=~/UBR1_RNA-seq_analysis/fastp/kallisto_out/
names='wild-type mutant'

ls -alh ${base_dir}/mutant_01_kallisto_out

for i in {1..5};
do
for n in ${names};
do
    d=${n}"_"0${i}"_kallisto_out/"
    a=${n}"_"0${i}"_abundance.tsv"
    p=${n}"_"0${i}"_pseudoalignments.tin.xls"
    cp -v ${base_dir}${d}${a} ${out_dir}
    cp -v ${base_dir}${d}${p} ${out_dir}
done
done

## check the results to make sure everything looks good
ls -alh ${out_dir}


## -----
## rsync to my machine
rsync -avzn mahlon@mesabi.msi.umn.edu:/home/albertf/mahlon/UBR1_RNA-seq_analysis/fastp/fastp_kallisto_out/ ~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/fastp/
#+END_SRC 

** deseq Analysis of 'fastp'-processed Data and Proteomics Results
#+BEGIN_SRC R :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/deseq_RNA_seq_proteomics.R
## -----
## load packages and set up

## check for Bioconductor and install if not available
ifelse(!requireNamespace("BiocManager", quietly = TRUE),
       install.packages("BiocManager",
                        dependencies = TRUE,
                        repos = "http://cran.wustl.edu/",
                        quiet = TRUE),
       paste0("Bioconductor available"))
require("BiocManager")

## -----
## load packages or install if not available
## have to split these out by bioconductor vs. non-bioconductor
## non-bioconductor
package_installer <- function(x){
    if(!requireNamespace(x, quietly = TRUE))
        install.packages(x, dependencies = TRUE,
                         repos = "http://cran.wustl.edu/",
                         quiet = TRUE, INSTALL_opts = '--no-lock')}

required_packages <- c("tidyverse", "DESeq2", "readxl", "lattice",
                       "readr", "qvalue", "sva", "tximport")

sapply(X = required_packages, FUN = package_installer)
sapply(X = required_packages, FUN = require, character.only = TRUE)


## bioconductor
bioc_package_installer <- function(x){if(!requireNamespace(x))
                                          BiocManager::install(x, INSTALL_opts = '--no-lock')}
bioc_packages <-  c("qvalue", "sva", "DESeq2", "tximportData",
                    "BUSpaRse", "biomaRt", "org.Sc.sgd.db")
sapply(X = bioc_packages, FUN = bioc_package_installer)
sapply(X = bioc_packages, FUN = require, character.only = TRUE)
## BiocManager::install("BUSpaRse")
## source("~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/deseq/get_TX.R")
## source("~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/deseq/utils.R")
## install.packages("remotes")
## remotes::install_github("lambdamoses/BUStoolsR")


## -----
## directories
base_dir   <- "~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/fastp/"

## -----
## sample information
## read in a list of samples and covariates
samples <- read.csv(paste0(base_dir, "ubr1_RNA-seq_sample_info.csv"),
                    header = T, sep = ",")

## make sure "wild-type" is the reference level for our factor
samples$Group <- relevel(samples$Group, ref = "wild_type")

## make sure "Batch" is a factor
samples$Batch <- as.factor(samples$Batch)

## scale the concentration variable
samples$Scale_Conc <- scale(samples$Concentration, center = T)

## make a list of abundance files for reading in using 'paste0'
files <- paste0(base_dir, "deseq_input/", samples$Sample, "_abundance.tsv")
names(files) <- as.character(samples$Sample)
## make sure you got the paths/names correct 
sapply(X = files, FUN = file.exists)


## -----
## annotations and other info
gene_annot <- read.table(file = paste0(base_dir, "ensemblGenes_ensembl83_160307_MOD.txt"),
                         sep = "\t", stringsAsFactors = F,
                         head = T)

rownames(gene_annot) <- gene_annot[, 1]
all_names <- gene_annot[, 1] 
names(all_names) <- gene_annot[, 1]
all_names[which(all_names == "")] <- names(all_names)[which(all_names == "")]


## -----
## read in the counts; creates a sample (columns) x gene (rows) matrix 
gene_counts <- sapply(X = files, FUN = function(x) {
                          curr_data <- read.table(x, sep = "\t", head = T)
                          curr_data[, "est_counts"]
                      })

## add in transcript names (these all have the same order in ea. abundance file)
unique(read.table(files[1], sep="\t", head=TRUE, stringsAsFactors = F)$target_id ==
    read.table(files[10], sep="\t", head=TRUE, stringsAsFactors = F)$target_id)

## add row names to transcript abundances
raw_gene_names <- read.table(files[1], sep="\t", head=TRUE, stringsAsFactors = F)$target_id
final_gene_names <- sapply(X = 1:length(raw_gene_names),
                           FUN = function(n){
                               strsplit(x = raw_gene_names[n], split = "_")[[1]][1] 
})
rownames(gene_counts) <- final_gene_names

head(gene_counts)


## -----
## "transcript integrity number" (TIN)-based filtering
## read TIN's for ea. gene, convert to a matrix that contains only the TIN score
## for each sample and drops the other columns of the associated "abundance.tsv" file
tins <- sapply(X = samples$Sample,
               FUN = function(x) {
                   curr_tin <- read.table(paste0(base_dir, "deseq_input/", x,
                                                 "_pseudoalignments.tin.xls"),
                                          head = T, stringsAsFactors = F)
                   rownames(curr_tin) <- curr_tin[, "geneID"]
                   curr_tin <- curr_tin[rownames(gene_counts), ]
                   curr_tin[, "TIN"]
})

## give the TIN scores the same gene names as our counts file
rownames(tins) <- final_gene_names

nrow(tins) ; nrow(gene_counts)

mean_tin <- rowMeans(tins)


## create a vector of effective gene length for filtering 
eff_gene_length <- read.table(paste0(base_dir, "deseq_input/",
                                     samples$Sample[1], "_abundance.tsv"),
                              sep = "\t", header = T)[, "eff_length"]
names(eff_gene_length) <- final_gene_names


## how many genes will each step of our filter below remove?
nrow(tins) ; length(mean_tin[mean_tin > 1])            ## ~150
length(eff_gene_length) ; length(eff_gene_length > 0)  ## 0
length(gene_counts[rowMin(round(gene_counts)) > 0, 1]) ## ~250

genes_filtered <- gene_counts[rowMin(round(gene_counts)) > 0
                              & apply(tins, 1, min) > 0
                              & eff_gene_length > 0, ]

c_filter <- rowSums(genes_filtered) > 1000
genes_filtered <- genes_filtered[c_filter, ]


## remove any rows w/ NAs
genes_filtered <- genes_filtered[complete.cases(genes_filtered), ]

nrow(gene_counts) ; nrow(genes_filtered)
## down to 6206 from 6612

write.table(x = genes_filtered,
            file = paste0(base_dir, "/gene_counts_filtered.csv"),
            append = F, quote = F, sep = ",",
            row.names = T, col.names = T)

col_data <- data.frame(samples[, c("OD", "Batch", "RIN", "Scale_Conc",
                                   "Concentration", "Group", "S_Area"), ])

## make sure column names match the order specified in 'col_data'
data.frame(x = colnames(genes_filtered),
           y = samples$Sample,
           w = col_data$Group)

## build the deseq model
## note: "Results tables are generated using the function results, which
## extracts a results table with log2 fold changes, p values and adjusted p
## values. With no additional arguments to results, the log2 fold change and
## Wald test p value will be for the last variable in the design formula, and if
## this is a factor, the comparison will be the last level of this variable over
## the reference level (see previous note on factor levels). However, the order
## of the variables of the design do not matter so long as the user specifies
## the comparison to build a results table for, using the name or contrast
## arguments of results." from -
## https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html
dds <- DESeqDataSetFromMatrix(countData = round(genes_filtered),
                              colData = col_data,
                              design = ~ OD + Batch + RIN + Group)

dds <- DESeq(dds, betaPrior = T)
res <- results(dds)
summary(res)

dat <- counts(dds, normalized = T)
idx <- rowMeans(dat) > 1
dat <- dat[idx, ]

mod  <- model.matrix(~ OD + Batch + RIN + Group,
                     colData(dds))
mod0 <- model.matrix(~ OD + Batch + RIN,
                     colData(dds))
svseq <- svaseq(dat, mod, mod0, n.sv = 2)

col_data_sva <- col_data
col_data_sva$SV1 <- svseq$sv[, 1]
col_data_sva$SV2 <- svseq$sv[, 2]


## -----
## final model that incorporates the surrogate vars 
dds_sva <- DESeqDataSetFromMatrix(countData = round(genes_filtered),
                                  colData = col_data_sva,
                                  design = ~ OD + Batch + RIN + SV1 + SV2 + Group)

dds_sva <- DESeq(dds_sva, betaPrior = T)
res_sva <- results(dds_sva) ; summary(res_sva)

vsd <- vst(dds_sva, blind = F)
plotPCA(vsd, intgroup = "Group")
plotPCA(vsd, intgroup = c("Group", "RNA_Batch"))
plotPCA(vsd, intgroup = c("Group", "Harvest_Batch"))


## -----
## work with the model output: 
## function to return short name for a vector
## of systematic gene names.  'n' below is the
## max value in a logical vector resulting from
## a test of whether a systematic name from the
## result list matches a name in the complete gene
## list - return the short name if there is one;
## if not, return the empty string. 
gene_checker <- function(x) {
    n <- which.max(x == gene_annot$geneID)
    gene_annot[n, "geneName"]
}

res_sva        <- as.data.frame(res_sva)

## add variables for plotting
res_sva$geneID <- rownames(res_sva)
res_sva$log2_fold_change <- log2(1 / 2^(res_sva$log2FoldChange))
res_sva$log10_pvalue     <- -1 * log10(res_sva$pvalue)
res_sva$log10_padj       <- -1 * log10(res_sva$padj)

res_sva$gene_name <- sapply(X = res_sva$geneID,
                            FUN = gene_checker)

## use 'res_out' for overplotting significant genes
res_out <- res_sva[res_sva$padj <= 0.1, ]
res_out$geneID <- rownames(res_out)

write.table(x = res_out,
            file = paste0(base_dir, "DE_genes_RNA_seq.csv"),
            append = F, quote = F, sep = ",",
            row.names = T, col.names = T)

write.table(x = res_out,
            file = paste0("~/emacs/N-end_Rule_QTL_paper/tables_drafts/", "RNA_seq_results.csv"),
            append = F, quote = F, sep = ",",
            row.names = T, col.names = T)


## -----
## plot RNA-seq results
text_genes <- res_out[res_out$log10_padj > 3.46, ]
text_genes[1 + nrow(text_genes), ] <- res_out["YGR184C", ]

pdf(file = paste0("~/emacs/N-end_Rule_QTL_paper/figures_drafts/",
                  gsub(pattern = " .*",
                       replacement = "",
                       x = Sys.time()),
                  "_DE_genes_RNA_volcano_final.pdf"))
print(
xyplot(log10_padj ~ log2_fold_change,
       data = res_sva,
       type = c("g", "p"),
       xlim = c(-0.8, 0.8),
       ylab = expression("Log"["10"]*" RNA "*italic("p")*" Value (BY vs. BY "*italic("UBR1")* "-469A>T)"),
       xlab = expression("Log"["2"]*" RNA Fold Change (BY vs. BY "*italic("UBR1")* "-469A>T)"),
       pch = 21,
       ## equiv. to 'bg' in base R 
       fill = gray(0.9, alpha = 0.5),
       col = gray(0.2, alpha = 0.5),
       cex = 1.2,
       scales = list(x = list(at = seq(from = -0.75, to = 0.75, by = 0.25)),
                     y = list(at = seq(from = 0, to = 25, by = 5)),
                     tck = c(1, 0)),
       key = list(corner = c(0.9975, 0.99),
                  points = list(pch = 21,
                                col = gray(0.2, alpha = 0.5),
                                fill = c(gray(0.7, alpha = 0.5),
                                         "#DDCC77"),
                                cex = 2.5),
                  text = list(labels = c(expression("Corrected "*italic("p")*" > 0.1"),
                                         expression("Corrected "*italic("p")*" < 0.1"))),
                  padding.text = 2.5,
                  between = 0.9,
                  background = gray(1.0, alpha = 0.75)),
       par.settings = list(axis.text = list(cex = 1.2),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25)),
       panel = function(...){
           panel.abline(h = 0, v = 0, lwd = 3, col = gray(0.4))
           panel.abline(h = seq(from = 0, to = 25, by = 5),
                        v = seq(from = -0.75, to = 0.75, by = 0.25),
                        col = gray(0.9),
                        lwd = 1)
           panel.xyplot(...)
           panel.abline(h = 1, col = gray(0.4), lty = 2, lwd = 3)
           panel.points(x = res_out$log2_fold_change,
                        y = res_out$log10_padj,
                        pch = 21,
                        fill = "#DDCC77",
                        col = gray(0.4, alpha = 0.5),
                        lwd = 1.2,
                        cex = 1.75)
           panel.text(ifelse(text_genes$gene_name != "",
                             text_genes$gene_name,
                             text_genes$geneID),
                      x = text_genes$log2_fold_change + 0.07,
                      y = text_genes$log10_padj)
})
)
dev.off()


## -----
## load in proteomics data
res_sva <- read.table(file = paste0(base_dir, "DE_genes_RNA_seq.csv"),
                      sep = ",", stringsAsFactors = F)

prot_dir  <- "~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/"
prot_file <- "formatted_proteomics_data.csv"
prot_dat  <- read.csv(paste0(prot_dir, prot_file),
                      sep = ",", stringsAsFactors = F,
                      header = T)

## need to format the proteomics data for downstream analysis
## first, get systematic gene names from the protein names field:
x <- prot_dat$Gene.ID
y <- gsub(pattern = ".*sce:", replacement = "", x = x)
length(y)                ## 3783
length(y[nchar(y) < 10]) ## 3775, so 8 w/ no yeast gene name

## what are the 8?
## A5PJX3 = albumin (bovine)
## Q06891 = raf1 (yeast); R0030W (2 micron plasmid gene)
## B2RA01 = keratin (human, i.e., contamination)
## P03871 = rep1 (yeast); R0020C (2 micron plasmid gene)
## P13645 = keratin (human)
## P35908 = keratin (human, type II)
## O00109 = keratin (human, cuticular)
## Q9NSB4 = keratin (human)

prot_dat$geneID <- gsub(pattern = ".*sce:",
                        replacement = "",
                        x = prot_dat$Gene.ID)

prot_name_filter <- nchar(prot_dat$geneID) < 10
length(prot_name_filter[prot_name_filter == F])

prot_dat <- prot_dat[prot_name_filter, ]

## convert the log2 fold change
prot_all$log2_fold_change <- log2(1 / prot_all$fold_change)
prot_all$log10_padj <- prot_all$log10_padj

## take the subset of the proteomics needed and match the columns from the RNA data
prot_all <- prot_dat[, c("Gene.Symbol", "fold_change", "padj", "geneID")]
colnames(prot_all)        <- c("gene_name", "fold_change", "padj", "geneID")
prot_all$log2_fold_change <- log2(1 / prot_all$fold_change)
prot_all$log10_padj       <- -1 * log10(prot_all$padj)
rownames(prot_all)        <- prot_all$geneID


## several hundred rows have no 'padj' value,
## so need the two-step filter here
prot_filter   <- prot_all$padj <= 0.1 & !is.na(prot_all$padj)
prot_filtered <- prot_all[prot_filter, ]
nrow(prot_filtered) ## 39, as expected

write.table(x = prot_filtered,
            file = paste0(base_dir, "DE_genes_proteomcis.csv"),
            append = F, quote = F, sep = ",",
            row.names = T, col.names = T)


## -----
## plot proteomics results
text_proteins <- prot_filtered[prot_filtered$log10_padj > 1.5, ]
text_proteins[1 + nrow(text_proteins), ] <- prot_filtered["YGR184C", ]

pdf(file = paste0("~/emacs/N-end_Rule_QTL_paper/figures_drafts/",
                  gsub(pattern = " .*",
                       replacement = "",
                       x = Sys.time()),
                  "_DE_genes_protein_volcano_final.pdf"))
print(
xyplot(log10_padj_protein_protein ~ log2_fold_change_protein_protein,
       data = prot_all,
       type = c("p"),
       xlim = c(-1.25, 1.1),
       ylim = c(-0.5, 9), 
       ylab = expression("Log"["10"]*" Protein "*italic("p")*" Value (BY vs. BY "*italic("UBR1")* "-469A>T)"),
       xlab = expression("Log"["2"]*" Protein Fold Change (BY vs. BY "*italic("UBR1")* "-469A>T)"),
       pch = 21,
       ## equiv. to 'bg' in base R 
       fill = gray(0.9, alpha = 0.5),
       col = gray(0.2, alpha = 0.5),
       cex = 1.2,
       scales = list(x = list(at = seq(from = -1.2, to = 0.8, by = 0.4),
                              labels = as.character(c(-1.7, seq(from = -0.8,
                                                          to = 0.8,
                                                          by = 0.4)))),
                     y = list(at = seq(from = 0, to = 14, by = 2),
                              labels = as.character(c(seq(from = 0,
                                                          to = 6,
                                                          by = 2), 13.5))),
                     tck = c(1, 0)),
       key = list(corner = c(0.9975, 0.99),
                  points = list(pch = 21,
                                col = gray(0.2, alpha = 0.5),
                                fill = c(gray(0.7, alpha = 0.5),
                                         "#6699CC"),
                                cex = 2.5),
                  text = list(labels = c(expression("Corrected "*italic("p")*" > 0.1"),
                                         expression("Corrected "*italic("p")*" < 0.1"))),
                  padding.text = 2.5,
                  between = 0.9,
                  background = gray(1.0, alpha = 0.75)),
       par.settings = list(axis.text = list(cex = 1.2),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25)),
       panel = function(...){
           panel.abline(h = 0, v = 0, lwd = 3, col = gray(0.4))
           panel.abline(v = seq(from = -1.2, to = 1.6, by = 0.4),
                        h = seq(from = 0, to = 14, by = 2), 
                        col = gray(0.9),
                        lwd = 1)
           panel.xyplot(...)
           panel.abline(h = 1, col = gray(0.4), lty = 2, lwd = 3)
           panel.points(x = prot_filtered$log2_fold_change_protein,
                        y = prot_filtered$log10_padj_protein,
                        pch = 21,
                        fill = "#6699CC",
                        col = gray(0.2, alpha = 0.5),
                        lwd = 1.1,
                        cex = 1.75)
           panel.text(ifelse(text_proteins$gene_name != "",
                             text_proteins$gene_name,
                             text_proteins$geneID),
                      x = text_proteins$log2_fold_change_protein,
                      y = text_proteins$log10_padj_protein + 0.2)
           ## off-axis vps36 plotting
           panel.points(x = -1.2, y = 8,
                        pch = 21,
                        fill = "#6699CC",
                        col = gray(0.2, alpha = 0.5),
                        lwd = 1.1,
                        cex = 1.75)
           panel.text("VPS36", x = -1.1, y = 8.3)
})
)
dev.off()


## format the RNA data the same way
str(res_sva)
RNA_all <- res_sva[, c("gene_name", "geneID",
                       "log2_fold_change", "padj",
                       "log10_padj")]
RNA_all$geneID <- rownames(res_sva)

## format these for later use in plotting
colnames(prot_all) <- paste0(colnames(prot_all), "_protein")
colnames(prot_all) <- gsub(pattern = "_protein_protein",
                           replacement = "_protein",
                           x = colnames(prot_all))
colnames(RNA_all)  <- paste0(colnames(RNA_all), "_RNA")
str(RNA_all) ; str(prot_all)
prot_all

## -----
## now, get the set of genes detected
## at both the protein and RNA levels 
both_all_only <- list()
for(i in 1:nrow(prot_all)) {
    x <- rownames(prot_all)[i]
    y <- x == rownames(RNA_all)
    if (max(y) > 0) {
        both_all_only[[i]] <- cbind(prot_all[i, ], RNA_all[which.max(y), ])
}
}

both_all_only <- do.call("rbind", both_all_only)
nrow(both_all_only) ; nrow(prot_all)

## now, get the genes that are DE at protein and RNA levels
both_de <- list()
for(i in 1:nrow(both_all_only)) {
    x <- both_all_only[i, ]
    y <- x$padj_protein <= 0.1 & x$padj_RNA <= 0.1 & !is.na(x$padj_protein)
    if (y > 0) {
        both_de[[i]] <- both_all_only[i, ]
}
}

both_de <- do.call("rbind", both_de)
## TMA10, HSP26, UBR1

## DE only at the RNA level
rna_de <- list()
for(i in 1:length(rownames(both_all_only))) {
    x <- both_all_only[i, ]
    y <- x$padj_protein > 0.1 & x$padj_RNA <= 0.1
    if (!is.na(x$padj_protein) & y > 0) {
        rna_de[[i]] <- both_all_only[i, ]
}
}

rna_de <- do.call("rbind", rna_de)

## DE only at the protein level
protein_de <- list()
for(i in 1:length(rownames(both_all_only))) {
    x <- both_all_only[i, ]
    y <- x$padj_protein <= 0.1 & x$padj_RNA > 0.1
    if (!is.na(x$padj_protein) & y > 0) {
        protein_de[[i]] <- both_all_only[i, ]
}
}

protein_de <- do.call("rbind", protein_de)

## -----
## plot protein vs. RNA abundance plot 
pdf(file = paste0("~/emacs/N-end_Rule_QTL_paper/figures_drafts/",
                  gsub(pattern = " .*",
                       replacement = "",
                       x = Sys.time()),
                  "_protein_RNA_scatter_final.pdf"))
print(
xyplot(log2_fold_change_protein ~ log2_fold_change_RNA,
       data = both_all_only,
       type = c("p"),
       pch = 21,
       ylab = expression("Log"["2"]*" Fold Change Protein (BY vs. BY "*italic("UBR1")* "-469A>T)"),
       xlab = expression("Log"["2"]*" Fold Change RNA (BY vs. BY "*italic("UBR1")* "-469A>T)"),
       fill = gray(0.9, alpha = 0.5),
       col = gray(0.2, alpha = 0.5),
       cex = 1.1,
       xlim = c(-0.45, 0.45),
       ylim = c(-1, 1),
       scales = list(x = list(at = seq(from = -1, to = 1, by = 0.2)),
                     y = list(at = seq(from = -1, to = 1, by = 0.2)),
                     tck = c(1, 0)),
       key = list(corner = c(0.0001, 0.998),
                  points = list(pch = 21,
                                col = gray(0.2, alpha = 0.5),
                                fill = c("#882255",
                                         "#DDCC77",
                                         "#6699CC",
                                         gray(0.7, alpha = 0.5)),
                                cex = 2.4),
                  text = list(labels = c(expression("Corrected "*italic("p")*" RNA and Protein < 0.1"),
                                         expression("Corrected "*italic("p")*" RNA only < 0.1"),
                                         expression("Corrected "*italic("p")*" Protein only < 0.1"),
                                         expression("Corrected "*italic("p")*" RNA and Protein > 0.1"))),
                  padding.text = 1.5,
                  between = 0.2),
                  ## background = gray(1.0, alpha = 0.75)),
       par.settings = list(axis.text = list(cex = 1.2),
                           par.ylab.text = list(cex = 1.25),
                           par.xlab.text = list(cex = 1.25)),
       panel = function(...) {
           panel.abline(h = 0, v = 0, lwd = 2, col = gray(0.4))
           panel.abline(h = 0, v = 0, lwd = 1, col = gray(0.9))
           panel.abline(h = seq(from = -1, to = 1, by = 0.2),
                        v = seq(from = -1, to = 1, by = 0.2),
                        col = gray(0.9))
           panel.xyplot(...)
           ## regression line for protein vs. mRNA 
           ## panel.abline(lm(both_all_only$log2_fold_change_protein
           ##                 ~ both_all_only$log2_fold_change_RNA),
           ##              lty = 2, col = gray(0.2))
           panel.points(x = both_de[, "log2_fold_change_RNA"],
                        y = both_de[, "log2_fold_change_protein"],
                        pch = 21, fill = "#882255",
                        col = gray(0.2, alpha = 0.5), cex = 2)
           panel.points(x = rna_de[, "log2_fold_change_RNA"],
                        y = rna_de[, "log2_fold_change_protein"],
                        pch = 21, fill = "#DDCC77",
                        col = gray(0.2, alpha = 0.5), cex = 2)                        
           panel.points(x = protein_de[, "log2_fold_change_RNA"],
                        y = protein_de[, "log2_fold_change_protein"],
                        pch = 21, fill = "#6699CC",
                        col = gray(0.2, alpha = 0.5), cex = 2)
           panel.text(both_de$gene_name_RNA,
                      x = both_de$log2_fold_change_RNA + 0.07,
                      y = both_de$log2_fold_change_protein,
                      col = "#882255")

}
)
)
dev.off()


## -----
## output supp tables
head(prot_all)

prot_out <- prot_all
colnames(prot_out) <- gsub(pattern = "_protein_protein",
                           replacement = "",
                           colnames(prot_all))

## write proteomics output to table
prot_out <- prot_out[, c(1, 4, 2, 5, 3, 6)]
ord_prot <- order(prot_out$padj, decreasing = F)
prot_out <- prot_out[ord_prot, c(2, 1, 3:6)]
head(prot_out)
write.table(x = prot_out,
            file = "~/emacs/N-end_Rule_QTL_paper/tables_drafts/all_protein_out.csv",
            append = F, quote = F, sep = ",",
            row.names = F, col.names = T)

save(prot_all, file = "~/emacs/N-end_Rule_QTL_paper/tables_drafts/all_proteomics_out.rdata")
save(res_sva, file = "~/emacs/N-end_Rule_QTL_paper/tables_drafts/all_RNA_out.rdata")
## load("~/emacs/N-end_Rule_QTL_paper/tables_drafts/all_proteomics_out.rdata")
## load("~/emacs/N-end_Rule_QTL_paper/tables_drafts/all_RNA_out.rdata")

RNA_out <- res_sva
RNA_out <- RNA_out[, c(10, 11, 1, 2, 4, 5, 6, 9)]
ord_rna <- order(RNA_out$padj, decreasing = F)
RNA_out <- RNA_out[ord_rna, ]
RNA_out$fold_change <- 2^(RNA_out$log2FoldChange)
RNA_out <- RNA_out[, c("geneID", "gene_name", "fold_change", "log2FoldChange", "padj", "log10_padj")]

write.table(x = RNA_out,
            file = "~/emacs/N-end_Rule_QTL_paper/tables_drafts/all_RNA_out.csv",
            append = F, quote = F, sep = ",",
            row.names = F, col.names = T)



## -----
## output lists for gene ontology analysis
ontology_dir <- paste0(base_dir, "gene_ontology/")

## RNA reference set
RNA_ref_set <- as.data.frame(rownames(RNA_all),
                             stringsAsFactors = F)

## all rows should have gene names:
nrow(RNA_ref_set)
length(RNA_ref_set[(nchar(RNA_ref_set[, 1]) > 5), 1])

write.table(x = RNA_ref_set,
            file = paste0(ontology_dir, "RNA_ref_set.txt"),
            append = F, quote = F, sep = "",
            row.names = F, col.names = F)

RNA_ref_set <- read.table(file = paste0(ontology_dir, "RNA_ref_set.txt"),
                          header = F,
                          quote = "",
                          stringsAsFactors = F)

## RNA test set 
RNA_test_set <- as.data.frame(rownames(res_out),
                             stringsAsFactors = F)

## all rows should have gene names:
nrow(RNA_test_set)
length(RNA_test_set[(nchar(RNA_test_set[, 1]) > 5), 1])

write.table(x = RNA_test_set,
            file = paste0(ontology_dir, "RNA_test_set.txt"),
            append = F, quote = F, sep = "",
            row.names = F, col.names = F)

RNA_test_set <- read.table(file = paste0(ontology_dir, "RNA_test_set.txt"),
                           header = F,
                           quote = "",
                           stringsAsFactors = F)

## protein reference set
prot_ref_set <- as.data.frame(rownames(prot_all),
                             stringsAsFactors = F)

## all rows should have gene names:
nrow(prot_ref_set)
length(prot_ref_set[(nchar(prot_ref_set[, 1]) > 5), 1])

write.table(x = prot_ref_set,
            file = paste0(ontology_dir, "prot_ref_set.txt"),
            append = F, quote = F, sep = "",
            row.names = F, col.names = F)

prot_ref_set <- read.table(file = paste0(ontology_dir, "prot_ref_set.txt"),
                           header = F,
                           quote = "",
                           stringsAsFactors = F)


## protein test set
prot_test_set <- as.data.frame(rownames(prot_filtered),
                             stringsAsFactors = F)

## all rows should have gene names:
nrow(prot_test_set)
length(prot_test_set[(nchar(prot_test_set[, 1]) > 5), 1])

write.table(x = prot_test_set,
            file = paste0(ontology_dir, "prot_test_set.txt"),
            append = F, quote = F, sep = "",
            row.names = F, col.names = F)

prot_test_set <- read.table(file = paste0(ontology_dir, "prot_test_set.txt"),
                            header = F,
                            quote = "",
                            stringsAsFactors = F)


## both ref set
both_ref_set <- as.data.frame(rownames(both_all_only),
                              stringsAsFactors = F)

## all rows should have gene names:
nrow(both_ref_set)
length(both_ref_set[(nchar(both_ref_set[, 1]) > 5), 1])

write.table(x = both_ref_set,
            file = paste0(ontology_dir, "both_ref_set.txt"),
            append = F, quote = F, sep = "",
            row.names = F, col.names = F)

both_ref_set <- read.table(file = paste0(ontology_dir, "both_ref_set.txt"),
                           header = F,
                           quote = "",
                           stringsAsFactors = F)

## both test set
both_test_set <- as.data.frame(rownames(both_only),
                              stringsAsFactors = F)

## all rows should have gene names:
nrow(both_test_set)
length(both_test_set[(nchar(both_test_set[, 1]) > 5), 1])

write.table(x = both_test_set,
            file = paste0(ontology_dir, "both_test_set.txt"),
            append = F, quote = F, sep = "",
            row.names = F, col.names = F)

both_test_set <- read.table(file = paste0(ontology_dir, "both_test_set.txt"),
                            header = F,
                            quote = "",
                            stringsAsFactors = F)

## systematic names don't seem to work well
## with pantherdb, so write out to entrez instead
## list of alternative geneIDs we can use: 
columns(org.Sc.sgd.db)

set_names <- c("RNA_reference_set_ensembl.txt", "protein_reference_set_ensembl.txt", 
               "RNA_test_set_ensembl.txt", "protein_test_set_ensembl.txt", 
               "both_reference_set_ensembl.txt", "both_test_set_ensembl.txt") 

set_list <- list(RNA_ref_set, prot_ref_set,
                 RNA_test_set, prot_test_set,
                 both_ref_set, both_test_set)

Map(f = function(x, y, ...) {
        ## convert systematic names to entrez via 'select': 
        out <- select(org.Sc.sgd.db,
                      keys = x$V1,
                      columns = c("ENTREZID"))
        ## keep only the entrezid:
        out <- out$SGD
        write.table(x = out, file = paste0(ontology_dir, y),
                    append = F, quote = F, sep = "",
                    row.names = F, col.names = F)
    }, x = set_list, y = set_names)
#+END_SRC

** Gene Ontology Enrichment Barplot                                        :R:
Gene ontology enrichments calculated from:
http://www.pantherdb.org

#+BEGIN_SRC R :tangle ~/emacs/N-end_Rule_QTL_paper/scripts/GO_barchart.R 
## -----
## setup for reading in results
library("tidyverse")
base_dir <- "~/emacs/N-end_Rule_QTL_paper/UBR1_RNA-seq_analysis/fastp"
ontology_dir <- paste0(base_dir, "/gene_ontology/GO_results/")


## -----
## read in each of the 3 results files
## 'biological process'
## the tables output by panther have strange
## formatting, so have to reformat them a 
## fair bit to get them into a readable format
biop <- read.table(file = dir(ontology_dir, full.names = T)[1],
                   sep = "\t", skip = 6, header = T, stringsAsFactors = F)

col_splits <- unlist(lapply(X = strsplit(x = colnames(biop)[3:ncol(biop)],
                                         split = "RNA_test_set_ensembl.txt.."),
                            FUN = function(x) {
                                x[2]
                            }))

colnames(biop) <- c("GO_Term", "ref_list", col_splits)

go_term <- unlist(lapply(X = strsplit(x = biop$GO_Term,
                                      split = " \\(.*"),
                         FUN = function(x) {
                             x[1]
                         }))

biop$go_term <- go_term
biop$ontology <- rep("bio_process", nrow(biop))


## 'cellular component'
cell_comp <- read.table(file = dir(ontology_dir, full.names = T)[2],
                        sep = "\t", skip = 6, header = T, stringsAsFactors = F)

col_splits <- unlist(lapply(X = strsplit(x = colnames(cell_comp)[3:ncol(cell_comp)],
                                         split = "RNA_test_set_ensembl.txt.."),
                            FUN = function(x) {
                                x[2]
                            }))

colnames(cell_comp) <- c("GO_Term", "ref_list", col_splits)

go_term <- unlist(lapply(X = strsplit(x = cell_comp$GO_Term,
                                      split = " \\(.*"),
                         FUN = function(x) {
                             x[1]
                         }))

cell_comp$go_term <- go_term
cell_comp$ontology <- rep("cellular_component", nrow(cell_comp))


## 'reactome pathway'
reactome <- read.table(file = dir(ontology_dir, full.names = T)[3],
                        sep = "\t", skip = 6, header = T, stringsAsFactors = F)

col_splits <- unlist(lapply(X = strsplit(x = colnames(reactome)[3:ncol(reactome)],
                                         split = "RNA_test_set_ensembl.txt.."),
                            FUN = function(x) {
                                x[2]
                            }))

colnames(reactome) <- c("GO_Term", "ref_list", col_splits)

go_term <- unlist(lapply(X = strsplit(x = reactome$GO_Term,
                                      split = " \\(.*"),
                         FUN = function(x) {
                             x[1]
                         }))

reactome$go_term <- go_term
reactome$ontology <- rep("reactome", nrow(reactome))


## -----
## merge into a single dataframe
all_terms <- list(biop, cell_comp, reactome)
all_terms <- do.call("rbind", all_terms)


## pick specific terms from the full list for plotting 
plot_rows <- c(7, 5, 4, 2, 1, 21, 19, 17)
plot_rows <- rev(plot_rows)
plot_terms <- all_terms[plot_rows, ]
 
plot_terms$go_fac <- factor(plot_terms$go_term,
                            levels = plot_terms$go_term,
                            labels = str_to_title(plot_terms$go_term))

plot_terms$fold.Enrichment.

go_cols <- ifelse(plot_terms$ontology == "bio_process",
                  gray(0.95),
                  "#D6EDE9")

better_y_lab <- c("Hsp90 Chaperone Cycle for\nSteroid Hormone Receptors", 
                  "Hsf1-Dependent\nTransactivation", 
                  "Cellular Response\nto Heat Stress", 
                  "Chaperone Cofactor-\nDependent Protein Refolding", 
                  "De Novo Posttranslational\nProtein Folding", 
                  "Chaperone-Mediated\nProtein Folding", 
                  "Cellular Response to\nMisfolded or Unfolded Protein",
                  "Ion Transmembrane\nTransport")

pdf(file = paste0("~/emacs/N-end_Rule_QTL_paper/figures_drafts/",
                  gsub(pattern = " .*",
                       replacement = "",
                       x = Sys.time()),
                  "_gene_ontology_plot_final.pdf"), width = 7)
print(
barchart(go_fac ~ fold.Enrichment.,
         data = plot_terms,
         horizontal = T,
         xlim = c(-2, 32.5),
         axes = T,
         stack = F,
         scales = list(tck = c(1, 0),
                       x = list(at = seq(from = 0, to = 30, by = 5),
                                cex = 1.25),
                       y = list(labels = rep("",
                                             length(levels(plot_terms$go_fac))),
                                cex = 1)),
         key = list(corner = c(0.99, 0.99),
                    rectangles = list(size = 5,
                                      border = T,
                                      col = c(gray(0.95),
                                              "#D6EDE9"),
                                      lwd = 10),
                    background = "white",
                    between = 0.5,
                    text = list(labels = c("GO Biological Process",
                                           "Reactome Pathway"),
                                cex = 1.2)),
         par.settings = list(par.xlab.text = list(cex = 1.25),
                             par.ylab.text = list(cex = 1.1),
                             ## allow text to be placed 
                             ## outside the plotting area 
                             clip = list(panel = F),
                             ## padding for text 
                             layout.widths = list(left.padding = 30)), 
         box.ratio = 2.5,
         col = go_cols,
         xlab = "Fold Enrichment",
         panel = function(...) {
             panel.abline(v = seq(from = 5, to = 30, by = 5),
                          lty = 1, col = gray(0.9))
             panel.barchart(...)
             ## panel.abline(h = 3.5, lty = 2, col = gray(0.4), lwd = 2)
             panel.text(paste0(rev(plot_terms[, 3]), " / ",
                               rev(plot_terms[, 4])),
                        x = rep(1, 8),
                        y = seq(from = 8, to = 1, by = -1))
             panel.text(paste(better_y_lab), x = -2.5,
                        y = seq(from = 1, to = 8, by = 1),
                        adj = 1,
                        cex = 1.2) 
         })
)

dev.off()
#+END_SRC
